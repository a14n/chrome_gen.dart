        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ChromeAppWindow class / chrome.app Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.app" data-type="ChromeAppWindow">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.app.html">chrome.app</a> &rsaquo; <a href="../chrome.app/ChromeAppWindow.html">ChromeAppWindow</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ChromeAppWindow</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Use the <code>chrome.app.window</code> API to create windows. Windows have an optional
frame with title bar and size controls. They are not associated with any
Chrome browser windows.</p>
<pre class="source">
class ChromeAppWindow extends ChromeApi {
 static final JsObject _app_window = chrome['app']['window'];

 ChromeAppWindow._();

 bool get available =&gt; _app_window != null;

 /**
  * The size and position of a window can be specified in a number of different
  * ways. The most simple option is not specifying anything at all, in which
  * case a default size and platform dependent position will be used.
  * 
  * Another option is to use the bounds property, which will put the window at
  * the specified coordinates with the specified size. If the window has a
  * frame, it's total size will be the size given plus the size of the frame;
  * that is, the size in bounds is the content size, not the window size.
  * 
  * To automatically remember the positions of windows you can give them ids.
  * If a window has an id, This id is used to remember the size and position of
  * the window whenever it is moved or resized. This size and position is then
  * used instead of the specified bounds on subsequent opening of a window with
  * the same id. If you need to open a window with an id at a location other
  * than the remembered default, you can create it hidden, move it to the
  * desired location, then show it.
  * 
  * Returns:
  * Called in the creating window (parent) before the load event is called in
  * the created window (child). The parent can set fields or functions on the
  * child usable from onload. E.g. background.js:
  * 
  * `function(created_window) { created_window.contentWindow.foo = function ()
  * { }; };`
  * 
  * window.js:
  * 
  *  `window.onload = function () { foo(); }`
  */
 Future&lt;AppWindow&gt; create(String url, [CreateWindowOptions options]) {
   if (_app_window == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;AppWindow&gt;.oneArg(_createAppWindow);
   _app_window.callMethod('create', [url, jsify(options), completer.callback]);
   return completer.future;
 }

 /**
  * Returns an [AppWindow] object for the current script context (ie JavaScript
  * 'window' object). This can also be called on a handle to a script context
  * for another page, for example: otherWindow.chrome.app.window.current().
  */
 AppWindow current() {
   if (_app_window == null) _throwNotAvailable();

   return _createAppWindow(_app_window.callMethod('current'));
 }

 void initializeAppWindow(dynamic state) {
   if (_app_window == null) _throwNotAvailable();

   _app_window.callMethod('initializeAppWindow', [jsify(state)]);
 }

 Stream get onBoundsChanged =&gt; _onBoundsChanged.stream;

 final ChromeStreamController _onBoundsChanged =
     new ChromeStreamController.noArgs(_app_window, 'onBoundsChanged');

 Stream get onClosed =&gt; _onClosed.stream;

 final ChromeStreamController _onClosed =
     new ChromeStreamController.noArgs(_app_window, 'onClosed');

 Stream get onFullscreened =&gt; _onFullscreened.stream;

 final ChromeStreamController _onFullscreened =
     new ChromeStreamController.noArgs(_app_window, 'onFullscreened');

 Stream get onMaximized =&gt; _onMaximized.stream;

 final ChromeStreamController _onMaximized =
     new ChromeStreamController.noArgs(_app_window, 'onMaximized');

 Stream get onMinimized =&gt; _onMinimized.stream;

 final ChromeStreamController _onMinimized =
     new ChromeStreamController.noArgs(_app_window, 'onMinimized');

 Stream get onRestored =&gt; _onRestored.stream;

 final ChromeStreamController _onRestored =
     new ChromeStreamController.noArgs(_app_window, 'onRestored');

 void _throwNotAvailable() {
   throw new UnsupportedError("'chrome.app.window' is not available");
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>ChromeAppWindow</strong></span></p>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="available">
<button class="show-code">Code</button>
final bool         <strong>available</strong> <a class="anchor-link"
            href="#available"
            title="Permalink to ChromeAppWindow.available">#</a>
        </h4>
        <div class="doc">
<div class="inherited">
<p>Returns true if the API is available. The common causes of an API not being
avilable are:</p><ul><li>a permission is missing in the application's manifest.json file</li><li>the API is defined on a newer version of Chrome then the current runtime</li></ul>
<div class="docs-inherited-from">docs inherited from <a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a> </div></div>
<pre class="source">
bool get available =&gt; _app_window != null;
</pre>
</div>
</div>
<div class="field"><h4 id="onBoundsChanged">
<button class="show-code">Code</button>
final Stream         <strong>onBoundsChanged</strong> <a class="anchor-link"
            href="#onBoundsChanged"
            title="Permalink to ChromeAppWindow.onBoundsChanged">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream get onBoundsChanged =&gt; _onBoundsChanged.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onClosed">
<button class="show-code">Code</button>
final Stream         <strong>onClosed</strong> <a class="anchor-link"
            href="#onClosed"
            title="Permalink to ChromeAppWindow.onClosed">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream get onClosed =&gt; _onClosed.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onFullscreened">
<button class="show-code">Code</button>
final Stream         <strong>onFullscreened</strong> <a class="anchor-link"
            href="#onFullscreened"
            title="Permalink to ChromeAppWindow.onFullscreened">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream get onFullscreened =&gt; _onFullscreened.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onMaximized">
<button class="show-code">Code</button>
final Stream         <strong>onMaximized</strong> <a class="anchor-link"
            href="#onMaximized"
            title="Permalink to ChromeAppWindow.onMaximized">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream get onMaximized =&gt; _onMaximized.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onMinimized">
<button class="show-code">Code</button>
final Stream         <strong>onMinimized</strong> <a class="anchor-link"
            href="#onMinimized"
            title="Permalink to ChromeAppWindow.onMinimized">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream get onMinimized =&gt; _onMinimized.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onRestored">
<button class="show-code">Code</button>
final Stream         <strong>onRestored</strong> <a class="anchor-link"
            href="#onRestored"
            title="Permalink to ChromeAppWindow.onRestored">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream get onRestored =&gt; _onRestored.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="create">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.app/AppWindow.html">AppWindow</a>&gt; <strong>create</strong>(String url, [<a href="../chrome.app/CreateWindowOptions.html">CreateWindowOptions</a> options]) <a class="anchor-link" href="#create"
              title="Permalink to ChromeAppWindow.create">#</a></h4>
<div class="doc">
<p>The size and position of a window can be specified in a number of different
ways. The most simple option is not specifying anything at all, in which
case a default size and platform dependent position will be used.</p>
<p>Another option is to use the bounds property, which will put the window at
the specified coordinates with the specified size. If the window has a
frame, it's total size will be the size given plus the size of the frame;
that is, the size in bounds is the content size, not the window size.</p>
<p>To automatically remember the positions of windows you can give them ids.
If a window has an id, This id is used to remember the size and position of
the window whenever it is moved or resized. This size and position is then
used instead of the specified bounds on subsequent opening of a window with
the same id. If you need to open a window with an id at a location other
than the remembered default, you can create it hidden, move it to the
desired location, then show it.</p>
<p>Returns:
Called in the creating window (parent) before the load event is called in
the created window (child). The parent can set fields or functions on the
child usable from onload. E.g. background.js:</p>
<p><code>function(created_window) { created_window.contentWindow.foo = function ()
{ }; };</code></p>
<p>window.js:</p>
<p> <code>window.onload = function () { foo(); }</code></p>
<pre class="source">
Future&lt;AppWindow&gt; create(String url, [CreateWindowOptions options]) {
 if (_app_window == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;AppWindow&gt;.oneArg(_createAppWindow);
 _app_window.callMethod('create', [url, jsify(options), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="current">
<button class="show-code">Code</button>
<a href="../chrome.app/AppWindow.html">AppWindow</a> <strong>current</strong>() <a class="anchor-link" href="#current"
              title="Permalink to ChromeAppWindow.current">#</a></h4>
<div class="doc">
<p>Returns an <a class="crossref" href="../chrome.app/AppWindow.html">AppWindow</a> object for the current script context (ie JavaScript
'window' object). This can also be called on a handle to a script context
for another page, for example: otherWindow.chrome.app.window.current().</p>
<pre class="source">
AppWindow current() {
 if (_app_window == null) _throwNotAvailable();

 return _createAppWindow(_app_window.callMethod('current'));
}
</pre>
</div>
</div>
<div class="method"><h4 id="initializeAppWindow">
<button class="show-code">Code</button>
void <strong>initializeAppWindow</strong>(state) <a class="anchor-link" href="#initializeAppWindow"
              title="Permalink to ChromeAppWindow.initializeAppWindow">#</a></h4>
<div class="doc">
<pre class="source">
void initializeAppWindow(dynamic state) {
 if (_app_window == null) _throwNotAvailable();

 _app_window.callMethod('initializeAppWindow', [jsify(state)]);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        

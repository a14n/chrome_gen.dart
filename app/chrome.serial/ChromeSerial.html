        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ChromeSerial class / chrome.serial Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.serial" data-type="ChromeSerial">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.serial.html">chrome.serial</a> &rsaquo; <a href="../chrome.serial/ChromeSerial.html">ChromeSerial</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ChromeSerial</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class ChromeSerial extends ChromeApi {
 static final JsObject _serial = chrome['serial'];

 ChromeSerial._();

 bool get available =&gt; _serial != null;

 /**
  * Returns names of valid ports on this machine, each of which is likely to be
  * valid to pass as the port argument to open(). The list is regenerated each
  * time this method is called, as port validity is dynamic.
  * 
  * [callback]: Called with the list of ports.
  */
 Future&lt;List&lt;String&gt;&gt; getPorts() {
   if (_serial == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;List&lt;String&gt;&gt;.oneArg(listify);
   _serial.callMethod('getPorts', [completer.callback]);
   return completer.future;
 }

 /**
  * Opens a connection to the given serial port.
  * [port]: The name of the serial port to open.
  * [options]: Connection options.
  * [callback]: Called when the connection has been opened.
  */
 Future&lt;OpenInfo&gt; open(String port, [OpenOptions options]) {
   if (_serial == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;OpenInfo&gt;.oneArg(_createOpenInfo);
   _serial.callMethod('open', [port, jsify(options), completer.callback]);
   return completer.future;
 }

 /**
  * Closes an open connection.
  * [connectionId]: The id of the opened connection.
  * [callback]: Called when the connection has been closed.
  * 
  * Returns:
  * Returns true if operation was successful.
  */
 Future&lt;bool&gt; close(int connectionId) {
   if (_serial == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
   _serial.callMethod('close', [connectionId, completer.callback]);
   return completer.future;
 }

 /**
  * Reads a byte from the given connection.
  * [connectionId]: The id of the connection.
  * [bytesToRead]: The number of bytes to read.
  * [callback]: Called when all the requested bytes have been read or when the
  * read blocks.
  */
 Future&lt;SerialReadInfo&gt; read(int connectionId, int bytesToRead) {
   if (_serial == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;SerialReadInfo&gt;.oneArg(_createReadInfo);
   _serial.callMethod('read', [connectionId, bytesToRead, completer.callback]);
   return completer.future;
 }

 /**
  * Writes a string to the given connection.
  * [connectionId]: The id of the connection.
  * [data]: The string to write.
  * [callback]: Called when the string has been written.
  */
 Future&lt;SerialWriteInfo&gt; write(int connectionId, ArrayBuffer data) {
   if (_serial == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;SerialWriteInfo&gt;.oneArg(_createWriteInfo);
   _serial.callMethod('write', [connectionId, jsify(data), completer.callback]);
   return completer.future;
 }

 /**
  * Flushes all bytes in the given connection's input and output buffers.
  * [connectionId]: The id of the connection.
  * [callback]: Called when the flush is complete.
  * 
  * Returns:
  * Returns true if operation was successful.
  */
 Future&lt;bool&gt; flush(int connectionId) {
   if (_serial == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
   _serial.callMethod('flush', [connectionId, completer.callback]);
   return completer.future;
 }

 Future&lt;ControlSignalOptions&gt; getControlSignals(int connectionId) {
   if (_serial == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;ControlSignalOptions&gt;.oneArg(_createControlSignalOptions);
   _serial.callMethod('getControlSignals', [connectionId, completer.callback]);
   return completer.future;
 }

 Future&lt;bool&gt; setControlSignals(int connectionId, ControlSignalOptions options) {
   if (_serial == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
   _serial.callMethod('setControlSignals', [connectionId, jsify(options), completer.callback]);
   return completer.future;
 }

 void _throwNotAvailable() {
   throw new UnsupportedError("'chrome.serial' is not available");
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>ChromeSerial</strong></span></p>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="available">
<button class="show-code">Code</button>
final bool         <strong>available</strong> <a class="anchor-link"
            href="#available"
            title="Permalink to ChromeSerial.available">#</a>
        </h4>
        <div class="doc">
<div class="inherited">
<p>Returns true if the API is available. The common causes of an API not being
avilable are:</p><ul><li>a permission is missing in the application's manifest.json file</li><li>the API is defined on a newer version of Chrome then the current runtime</li></ul>
<div class="docs-inherited-from">docs inherited from <a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a> </div></div>
<pre class="source">
bool get available =&gt; _serial != null;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="close">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>close</strong>(int connectionId) <a class="anchor-link" href="#close"
              title="Permalink to ChromeSerial.close">#</a></h4>
<div class="doc">
<p>Closes an open connection.

<span class="param">connectionId</span>: The id of the opened connection.
<code>callback</code>: Called when the connection has been closed.</p>
<p>Returns:
Returns true if operation was successful.</p>
<pre class="source">
Future&lt;bool&gt; close(int connectionId) {
 if (_serial == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
 _serial.callMethod('close', [connectionId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="flush">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>flush</strong>(int connectionId) <a class="anchor-link" href="#flush"
              title="Permalink to ChromeSerial.flush">#</a></h4>
<div class="doc">
<p>Flushes all bytes in the given connection's input and output buffers.

<span class="param">connectionId</span>: The id of the connection.
<code>callback</code>: Called when the flush is complete.</p>
<p>Returns:
Returns true if operation was successful.</p>
<pre class="source">
Future&lt;bool&gt; flush(int connectionId) {
 if (_serial == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
 _serial.callMethod('flush', [connectionId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getControlSignals">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.serial/ControlSignalOptions.html">ControlSignalOptions</a>&gt; <strong>getControlSignals</strong>(int connectionId) <a class="anchor-link" href="#getControlSignals"
              title="Permalink to ChromeSerial.getControlSignals">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;ControlSignalOptions&gt; getControlSignals(int connectionId) {
 if (_serial == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;ControlSignalOptions&gt;.oneArg(_createControlSignalOptions);
 _serial.callMethod('getControlSignals', [connectionId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getPorts">
<button class="show-code">Code</button>
Future&lt;List&lt;String&gt;&gt; <strong>getPorts</strong>() <a class="anchor-link" href="#getPorts"
              title="Permalink to ChromeSerial.getPorts">#</a></h4>
<div class="doc">
<p>Returns names of valid ports on this machine, each of which is likely to be
valid to pass as the port argument to open(). The list is regenerated each
time this method is called, as port validity is dynamic.</p>
<p><code>callback</code>: Called with the list of ports.</p>
<pre class="source">
Future&lt;List&lt;String&gt;&gt; getPorts() {
 if (_serial == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;List&lt;String&gt;&gt;.oneArg(listify);
 _serial.callMethod('getPorts', [completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="open">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.serial/OpenInfo.html">OpenInfo</a>&gt; <strong>open</strong>(String port, [<a href="../chrome.serial/OpenOptions.html">OpenOptions</a> options]) <a class="anchor-link" href="#open"
              title="Permalink to ChromeSerial.open">#</a></h4>
<div class="doc">
<p>Opens a connection to the given serial port.

<span class="param">port</span>: The name of the serial port to open.

<span class="param">options</span>: Connection options.
<code>callback</code>: Called when the connection has been opened.</p>
<pre class="source">
Future&lt;OpenInfo&gt; open(String port, [OpenOptions options]) {
 if (_serial == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;OpenInfo&gt;.oneArg(_createOpenInfo);
 _serial.callMethod('open', [port, jsify(options), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="read">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.serial/SerialReadInfo.html">SerialReadInfo</a>&gt; <strong>read</strong>(int connectionId, int bytesToRead) <a class="anchor-link" href="#read"
              title="Permalink to ChromeSerial.read">#</a></h4>
<div class="doc">
<p>Reads a byte from the given connection.

<span class="param">connectionId</span>: The id of the connection.

<span class="param">bytesToRead</span>: The number of bytes to read.
<code>callback</code>: Called when all the requested bytes have been read or when the
read blocks.</p>
<pre class="source">
Future&lt;SerialReadInfo&gt; read(int connectionId, int bytesToRead) {
 if (_serial == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;SerialReadInfo&gt;.oneArg(_createReadInfo);
 _serial.callMethod('read', [connectionId, bytesToRead, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setControlSignals">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>setControlSignals</strong>(int connectionId, <a href="../chrome.serial/ControlSignalOptions.html">ControlSignalOptions</a> options) <a class="anchor-link" href="#setControlSignals"
              title="Permalink to ChromeSerial.setControlSignals">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;bool&gt; setControlSignals(int connectionId, ControlSignalOptions options) {
 if (_serial == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
 _serial.callMethod('setControlSignals', [connectionId, jsify(options), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="write">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.serial/SerialWriteInfo.html">SerialWriteInfo</a>&gt; <strong>write</strong>(int connectionId, <a href="../chrome.src.common_exp/ArrayBuffer.html">ArrayBuffer</a> data) <a class="anchor-link" href="#write"
              title="Permalink to ChromeSerial.write">#</a></h4>
<div class="doc">
<p>Writes a string to the given connection.

<span class="param">connectionId</span>: The id of the connection.

<span class="param">data</span>: The string to write.
<code>callback</code>: Called when the string has been written.</p>
<pre class="source">
Future&lt;SerialWriteInfo&gt; write(int connectionId, ArrayBuffer data) {
 if (_serial == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;SerialWriteInfo&gt;.oneArg(_createWriteInfo);
 _serial.callMethod('write', [connectionId, jsify(data), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        

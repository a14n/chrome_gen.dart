        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ChromeSerial class / chrome.serial Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.serial" data-type="ChromeSerial">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.serial.html">chrome.serial</a> &rsaquo; <a href="../chrome.serial/ChromeSerial.html">ChromeSerial</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ChromeSerial</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class ChromeSerial {
 static final JsObject _serial = chrome['serial'];

 ChromeSerial._();

 /**
  * Returns names of valid ports on this machine, each of which is likely to be
  * valid to pass as the port argument to open(). The list is regenerated each
  * time this method is called, as port validity is dynamic.
  * 
  * [callback]: Called with the list of ports.
  * 
  * Returns:
  * Copyright (c) 2012 The Chromium Authors. All rights reserved. Use of this
  * source code is governed by a BSD-style license that can be found in the
  * LICENSE file. Use the `chrome.serial` API to read from and write to a
  * device connected to a serial port.
  */
 Future&lt;String&gt; getPorts() {
   var completer = new ChromeCompleter&lt;String&gt;.oneArg();
   _serial.callMethod('getPorts', [completer.callback]);
   return completer.future;
 }

 /**
  * Opens a connection to the given serial port.
  * [port]: The name of the serial port to open.
  * [options]: Connection options.
  * [callback]: Called when the connection has been opened.
  */
 Future&lt;OpenInfo&gt; open(String port, [OpenOptions options]) {
   var completer = new ChromeCompleter&lt;OpenInfo&gt;.oneArg(_createOpenInfo);
   _serial.callMethod('open', [port, jsify(options), completer.callback]);
   return completer.future;
 }

 /**
  * Closes an open connection.
  * [connectionId]: The id of the opened connection.
  * [callback]: Called when the connection has been closed.
  * 
  * Returns:
  * Returns true if operation was successful.
  */
 Future&lt;bool&gt; close(int connectionId) {
   var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
   _serial.callMethod('close', [connectionId, completer.callback]);
   return completer.future;
 }

 /**
  * Reads a byte from the given connection.
  * [connectionId]: The id of the connection.
  * [bytesToRead]: The number of bytes to read.
  * [callback]: Called when all the requested bytes have been read or when the
  * read blocks.
  */
 Future&lt;SerialReadInfo&gt; read(int connectionId, int bytesToRead) {
   var completer = new ChromeCompleter&lt;SerialReadInfo&gt;.oneArg(_createSerialReadInfo);
   _serial.callMethod('read', [connectionId, bytesToRead, completer.callback]);
   return completer.future;
 }

 /**
  * Writes a string to the given connection.
  * [connectionId]: The id of the connection.
  * [data]: The string to write.
  * [callback]: Called when the string has been written.
  */
 Future&lt;SerialWriteInfo&gt; write(int connectionId, ArrayBuffer data) {
   var completer = new ChromeCompleter&lt;SerialWriteInfo&gt;.oneArg(_createSerialWriteInfo);
   _serial.callMethod('write', [connectionId, jsify(data), completer.callback]);
   return completer.future;
 }

 /**
  * Flushes all bytes in the given connection's input and output buffers.
  * [connectionId]: The id of the connection.
  * [callback]: Called when the flush is complete.
  * 
  * Returns:
  * Returns true if operation was successful.
  */
 Future&lt;bool&gt; flush(int connectionId) {
   var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
   _serial.callMethod('flush', [connectionId, completer.callback]);
   return completer.future;
 }

 Future&lt;ControlSignalOptions&gt; getControlSignals(int connectionId) {
   var completer = new ChromeCompleter&lt;ControlSignalOptions&gt;.oneArg(_createControlSignalOptions);
   _serial.callMethod('getControlSignals', [connectionId, completer.callback]);
   return completer.future;
 }

 Future&lt;bool&gt; setControlSignals(int connectionId, ControlSignalOptions options) {
   var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
   _serial.callMethod('setControlSignals', [connectionId, jsify(options), completer.callback]);
   return completer.future;
 }
}
</pre>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="close">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>close</strong>(int connectionId) <a class="anchor-link" href="#close"
              title="Permalink to ChromeSerial.close">#</a></h4>
<div class="doc">
<p>Closes an open connection.

<span class="param">connectionId</span>: The id of the opened connection.
<code>callback</code>: Called when the connection has been closed.</p>
<p>Returns:
Returns true if operation was successful.</p>
<pre class="source">
Future&lt;bool&gt; close(int connectionId) {
 var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
 _serial.callMethod('close', [connectionId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="flush">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>flush</strong>(int connectionId) <a class="anchor-link" href="#flush"
              title="Permalink to ChromeSerial.flush">#</a></h4>
<div class="doc">
<p>Flushes all bytes in the given connection's input and output buffers.

<span class="param">connectionId</span>: The id of the connection.
<code>callback</code>: Called when the flush is complete.</p>
<p>Returns:
Returns true if operation was successful.</p>
<pre class="source">
Future&lt;bool&gt; flush(int connectionId) {
 var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
 _serial.callMethod('flush', [connectionId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getControlSignals">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.serial/ControlSignalOptions.html">ControlSignalOptions</a>&gt; <strong>getControlSignals</strong>(int connectionId) <a class="anchor-link" href="#getControlSignals"
              title="Permalink to ChromeSerial.getControlSignals">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;ControlSignalOptions&gt; getControlSignals(int connectionId) {
 var completer = new ChromeCompleter&lt;ControlSignalOptions&gt;.oneArg(_createControlSignalOptions);
 _serial.callMethod('getControlSignals', [connectionId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getPorts">
<button class="show-code">Code</button>
Future&lt;String&gt; <strong>getPorts</strong>() <a class="anchor-link" href="#getPorts"
              title="Permalink to ChromeSerial.getPorts">#</a></h4>
<div class="doc">
<p>Returns names of valid ports on this machine, each of which is likely to be
valid to pass as the port argument to open(). The list is regenerated each
time this method is called, as port validity is dynamic.</p>
<p><code>callback</code>: Called with the list of ports.</p>
<p>Returns:
Copyright (c) 2012 The Chromium Authors. All rights reserved. Use of this
source code is governed by a BSD-style license that can be found in the
LICENSE file. Use the <code>chrome.serial</code> API to read from and write to a
device connected to a serial port.</p>
<pre class="source">
Future&lt;String&gt; getPorts() {
 var completer = new ChromeCompleter&lt;String&gt;.oneArg();
 _serial.callMethod('getPorts', [completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="open">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.serial/OpenInfo.html">OpenInfo</a>&gt; <strong>open</strong>(String port, [<a href="../chrome.serial/OpenOptions.html">OpenOptions</a> options]) <a class="anchor-link" href="#open"
              title="Permalink to ChromeSerial.open">#</a></h4>
<div class="doc">
<p>Opens a connection to the given serial port.

<span class="param">port</span>: The name of the serial port to open.

<span class="param">options</span>: Connection options.
<code>callback</code>: Called when the connection has been opened.</p>
<pre class="source">
Future&lt;OpenInfo&gt; open(String port, [OpenOptions options]) {
 var completer = new ChromeCompleter&lt;OpenInfo&gt;.oneArg(_createOpenInfo);
 _serial.callMethod('open', [port, jsify(options), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="read">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.serial/SerialReadInfo.html">SerialReadInfo</a>&gt; <strong>read</strong>(int connectionId, int bytesToRead) <a class="anchor-link" href="#read"
              title="Permalink to ChromeSerial.read">#</a></h4>
<div class="doc">
<p>Reads a byte from the given connection.

<span class="param">connectionId</span>: The id of the connection.

<span class="param">bytesToRead</span>: The number of bytes to read.
<code>callback</code>: Called when all the requested bytes have been read or when the
read blocks.</p>
<pre class="source">
Future&lt;SerialReadInfo&gt; read(int connectionId, int bytesToRead) {
 var completer = new ChromeCompleter&lt;SerialReadInfo&gt;.oneArg(_createSerialReadInfo);
 _serial.callMethod('read', [connectionId, bytesToRead, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setControlSignals">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>setControlSignals</strong>(int connectionId, <a href="../chrome.serial/ControlSignalOptions.html">ControlSignalOptions</a> options) <a class="anchor-link" href="#setControlSignals"
              title="Permalink to ChromeSerial.setControlSignals">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;bool&gt; setControlSignals(int connectionId, ControlSignalOptions options) {
 var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
 _serial.callMethod('setControlSignals', [connectionId, jsify(options), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="write">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.serial/SerialWriteInfo.html">SerialWriteInfo</a>&gt; <strong>write</strong>(int connectionId, <a href="../chrome.src.common_exp/ArrayBuffer.html">ArrayBuffer</a> data) <a class="anchor-link" href="#write"
              title="Permalink to ChromeSerial.write">#</a></h4>
<div class="doc">
<p>Writes a string to the given connection.

<span class="param">connectionId</span>: The id of the connection.

<span class="param">data</span>: The string to write.
<code>callback</code>: Called when the string has been written.</p>
<pre class="source">
Future&lt;SerialWriteInfo&gt; write(int connectionId, ArrayBuffer data) {
 var completer = new ChromeCompleter&lt;SerialWriteInfo&gt;.oneArg(_createSerialWriteInfo);
 _serial.callMethod('write', [connectionId, jsify(data), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        

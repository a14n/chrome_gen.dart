        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ChromeUsb class / chrome.usb Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.usb" data-type="ChromeUsb">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.usb.html">chrome.usb</a> &rsaquo; <a href="../chrome.usb/ChromeUsb.html">ChromeUsb</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ChromeUsb</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class ChromeUsb extends ChromeApi {
 static final JsObject _usb = chrome['usb'];

 ChromeUsb._();

 bool get available =&gt; _usb != null;

 /**
  * Lists USB devices specified by vendorId/productId/interfaceId tuple.
  * [options]: The properties to search for on target devices.
  * [callback]: Invoked with a list of [Device]s on complete.
  */
 Future&lt;List&lt;Device&gt;&gt; getDevices(EnumerateDevicesOptions options) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;List&lt;Device&gt;&gt;.oneArg((e) =&gt; listify(e, _createDevice));
   _usb.callMethod('getDevices', [jsify(options), completer.callback]);
   return completer.future;
 }

 /**
  * This method is ChromeOS specific. Calling this method on other platforms
  * will fail. Requests access from the permission broker to an OS claimed
  * device if the given interface on the device is not claimed.
  * 
  * [device]: The device to request access to.
  * [interfaceId]:
  */
 Future&lt;bool&gt; requestAccess(Device device, int interfaceId) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
   _usb.callMethod('requestAccess', [jsify(device), interfaceId, completer.callback]);
   return completer.future;
 }

 /**
  * Opens a USB device returned by [getDevices].
  * [device]: The device to open.
  * [callback]: Invoked with the created ConnectionHandle on complete.
  */
 Future&lt;ConnectionHandle&gt; openDevice(Device device) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;ConnectionHandle&gt;.oneArg(_createConnectionHandle);
   _usb.callMethod('openDevice', [jsify(device), completer.callback]);
   return completer.future;
 }

 /**
  * Finds USB devices specified by the vendorId/productId/interfaceId tuple
  * and, if permissions allow, opens them for use.
  * 
  * On Chrome OS, you can specify the interfaceId. In that case the method will
  * request access from permission broker in the same way as in
  * [requestUsbAcess].
  * 
  * If the access request is rejected, or the device is failed to be opened,
  * its connection handle will not be created or returned.
  * 
  * Calling this method is equivalent to calling [getDevices] followed by a
  * series of [requestAccess] (if it is on ChromeOs) and [openDevice] calls,
  * and returning all the successfully opened connection handles.
  * 
  * [options]: The properties to search for on target devices.
  * [callback]: Invoked with the opened ConnectionHandle on complete.
  */
 Future&lt;List&lt;ConnectionHandle&gt;&gt; findDevices(EnumerateDevicesAndRequestAccessOptions options) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;List&lt;ConnectionHandle&gt;&gt;.oneArg((e) =&gt; listify(e, _createConnectionHandle));
   _usb.callMethod('findDevices', [jsify(options), completer.callback]);
   return completer.future;
 }

 /**
  * Closes a connection handle. Invoking operations on a device after it has
  * been closed is a safe operation, but causes no action to be taken.
  * [handle]: The connection handle to close.
  * [callback]: The callback to invoke once the device is closed.
  */
 Future closeDevice(ConnectionHandle handle) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _usb.callMethod('closeDevice', [jsify(handle), completer.callback]);
   return completer.future;
 }

 /**
  * Lists all the interfaces on the USB device.
  * [handle]: The device from which the interfaces should be listed.
  * [callback]: The callback to invoke when the interfaces are enumerated.
  */
 Future&lt;List&lt;InterfaceDescriptor&gt;&gt; listInterfaces(ConnectionHandle handle) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;List&lt;InterfaceDescriptor&gt;&gt;.oneArg((e) =&gt; listify(e, _createInterfaceDescriptor));
   _usb.callMethod('listInterfaces', [jsify(handle), completer.callback]);
   return completer.future;
 }

 /**
  * Claims an interface on the specified USB device. Before you can transfer
  * data with endpoints, you must claim their parent interfaces. Only one
  * connection handle on the same host can claim each interface. If the
  * interface is already claimed, this call will fail.
  * 
  * You shall call releaseInterface when the interface is not needed anymore.
  * 
  * [handle]: The device on which the interface is to be claimed.
  * [interface]: The interface number to be claimed.
  * [callback]: The callback to invoke once the interface is claimed.
  */
 Future claimInterface(ConnectionHandle handle, int interfaceNumber) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _usb.callMethod('claimInterface', [jsify(handle), interfaceNumber, completer.callback]);
   return completer.future;
 }

 /**
  * Releases a claim to an interface on the provided device.
  * [handle]: The device on which the interface is to be released.
  * [interface]: The interface number to be released.
  * [callback]: The callback to invoke once the interface is released.
  */
 Future releaseInterface(ConnectionHandle handle, int interfaceNumber) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _usb.callMethod('releaseInterface', [jsify(handle), interfaceNumber, completer.callback]);
   return completer.future;
 }

 /**
  * Selects an alternate setting on a previously claimed interface on a device.
  * [handle]: The device on which the interface settings are to be set.
  * [interface]: The interface number to be set.
  * [alternateSetting]: The alternate setting to set.
  * [callback]: The callback to invoke once the interface setting is set.
  */
 Future setInterfaceAlternateSetting(ConnectionHandle handle, int interfaceNumber, int alternateSetting) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _usb.callMethod('setInterfaceAlternateSetting', [jsify(handle), interfaceNumber, alternateSetting, completer.callback]);
   return completer.future;
 }

 /**
  * Performs a control transfer on the specified device. See the
  * ControlTransferInfo structure for the parameters required to make a
  * transfer.
  * 
  * Conceptually control transfer talks to the device itself. You do not need
  * to claim interface 0 to perform a control transfer.
  * 
  * [handle]: A connection handle to make the transfer on.
  * [transferInfo]: The parameters to the transfer. See ControlTransferInfo.
  * [callback]: Invoked once the transfer has completed.
  */
 Future&lt;TransferResultInfo&gt; controlTransfer(ConnectionHandle handle, ControlTransferInfo transferInfo) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;TransferResultInfo&gt;.oneArg(_createTransferResultInfo);
   _usb.callMethod('controlTransfer', [jsify(handle), jsify(transferInfo), completer.callback]);
   return completer.future;
 }

 /**
  * Performs a bulk transfer on the specified device.
  * [handle]: A connection handle to make the transfer on.
  * [transferInfo]: The parameters to the transfer. See GenericTransferInfo.
  * [callback]: Invoked once the transfer has completed.
  */
 Future&lt;TransferResultInfo&gt; bulkTransfer(ConnectionHandle handle, GenericTransferInfo transferInfo) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;TransferResultInfo&gt;.oneArg(_createTransferResultInfo);
   _usb.callMethod('bulkTransfer', [jsify(handle), jsify(transferInfo), completer.callback]);
   return completer.future;
 }

 /**
  * Performs an interrupt transfer on the specified device.
  * [handle]: A connection handle to make the transfer on.
  * [transferInfo]: The parameters to the transfer. See GenericTransferInfo.
  * [callback]: Invoked once the transfer has completed.
  */
 Future&lt;TransferResultInfo&gt; interruptTransfer(ConnectionHandle handle, GenericTransferInfo transferInfo) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;TransferResultInfo&gt;.oneArg(_createTransferResultInfo);
   _usb.callMethod('interruptTransfer', [jsify(handle), jsify(transferInfo), completer.callback]);
   return completer.future;
 }

 /**
  * Performs an isochronous transfer on the specific device.
  * [handle]: A connection handle to make the transfer on.
  * [transferInfo]: The parameters to the transfer. See
  * IsochronousTransferInfo.
  * [callback]: Invoked once the transfer has been completed.
  */
 Future&lt;TransferResultInfo&gt; isochronousTransfer(ConnectionHandle handle, IsochronousTransferInfo transferInfo) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;TransferResultInfo&gt;.oneArg(_createTransferResultInfo);
   _usb.callMethod('isochronousTransfer', [jsify(handle), jsify(transferInfo), completer.callback]);
   return completer.future;
 }

 /**
  * Tries to reset the USB device and restores it to the previous status. If
  * the reset fails, the given connection handle will be closed and the USB
  * device will appear to be disconnected then reconnected. In that case you
  * must call [getDevices] or [findDevices] again to acquire the device.
  * 
  * [handle]: A connection handle to reset.
  * [callback]: Invoked once the device is reset with a boolean indicating
  * whether the reset is completed successfully.
  */
 Future&lt;bool&gt; resetDevice(ConnectionHandle handle) {
   if (_usb == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
   _usb.callMethod('resetDevice', [jsify(handle), completer.callback]);
   return completer.future;
 }

 void _throwNotAvailable() {
   throw new UnsupportedError("'chrome.usb' is not available");
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>ChromeUsb</strong></span></p>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="available">
<button class="show-code">Code</button>
final bool         <strong>available</strong> <a class="anchor-link"
            href="#available"
            title="Permalink to ChromeUsb.available">#</a>
        </h4>
        <div class="doc">
<div class="inherited">
<p>Returns true if the API is available. The common causes of an API not being
avilable are:</p><ul><li>a permission is missing in the application's manifest.json file</li><li>the API is defined on a newer version of Chrome then the current runtime</li></ul>
<div class="docs-inherited-from">docs inherited from <a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a> </div></div>
<pre class="source">
bool get available =&gt; _usb != null;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="bulkTransfer">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.usb/TransferResultInfo.html">TransferResultInfo</a>&gt; <strong>bulkTransfer</strong>(<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a> handle, <a href="../chrome.usb/GenericTransferInfo.html">GenericTransferInfo</a> transferInfo) <a class="anchor-link" href="#bulkTransfer"
              title="Permalink to ChromeUsb.bulkTransfer">#</a></h4>
<div class="doc">
<p>Performs a bulk transfer on the specified device.

<span class="param">handle</span>: A connection handle to make the transfer on.

<span class="param">transferInfo</span>: The parameters to the transfer. See GenericTransferInfo.
<code>callback</code>: Invoked once the transfer has completed.</p>
<pre class="source">
Future&lt;TransferResultInfo&gt; bulkTransfer(ConnectionHandle handle, GenericTransferInfo transferInfo) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;TransferResultInfo&gt;.oneArg(_createTransferResultInfo);
 _usb.callMethod('bulkTransfer', [jsify(handle), jsify(transferInfo), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="claimInterface">
<button class="show-code">Code</button>
Future <strong>claimInterface</strong>(<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a> handle, int interfaceNumber) <a class="anchor-link" href="#claimInterface"
              title="Permalink to ChromeUsb.claimInterface">#</a></h4>
<div class="doc">
<p>Claims an interface on the specified USB device. Before you can transfer
data with endpoints, you must claim their parent interfaces. Only one
connection handle on the same host can claim each interface. If the
interface is already claimed, this call will fail.</p>
<p>You shall call releaseInterface when the interface is not needed anymore.</p>
<p>
<span class="param">handle</span>: The device on which the interface is to be claimed.
<code>interface</code>: The interface number to be claimed.
<code>callback</code>: The callback to invoke once the interface is claimed.</p>
<pre class="source">
Future claimInterface(ConnectionHandle handle, int interfaceNumber) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _usb.callMethod('claimInterface', [jsify(handle), interfaceNumber, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="closeDevice">
<button class="show-code">Code</button>
Future <strong>closeDevice</strong>(<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a> handle) <a class="anchor-link" href="#closeDevice"
              title="Permalink to ChromeUsb.closeDevice">#</a></h4>
<div class="doc">
<p>Closes a connection handle. Invoking operations on a device after it has
been closed is a safe operation, but causes no action to be taken.

<span class="param">handle</span>: The connection handle to close.
<code>callback</code>: The callback to invoke once the device is closed.</p>
<pre class="source">
Future closeDevice(ConnectionHandle handle) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _usb.callMethod('closeDevice', [jsify(handle), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="controlTransfer">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.usb/TransferResultInfo.html">TransferResultInfo</a>&gt; <strong>controlTransfer</strong>(<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a> handle, <a href="../chrome.usb/ControlTransferInfo.html">ControlTransferInfo</a> transferInfo) <a class="anchor-link" href="#controlTransfer"
              title="Permalink to ChromeUsb.controlTransfer">#</a></h4>
<div class="doc">
<p>Performs a control transfer on the specified device. See the
ControlTransferInfo structure for the parameters required to make a
transfer.</p>
<p>Conceptually control transfer talks to the device itself. You do not need
to claim interface 0 to perform a control transfer.</p>
<p>
<span class="param">handle</span>: A connection handle to make the transfer on.

<span class="param">transferInfo</span>: The parameters to the transfer. See ControlTransferInfo.
<code>callback</code>: Invoked once the transfer has completed.</p>
<pre class="source">
Future&lt;TransferResultInfo&gt; controlTransfer(ConnectionHandle handle, ControlTransferInfo transferInfo) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;TransferResultInfo&gt;.oneArg(_createTransferResultInfo);
 _usb.callMethod('controlTransfer', [jsify(handle), jsify(transferInfo), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="findDevices">
<button class="show-code">Code</button>
Future&lt;List&lt;<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a>&gt;&gt; <strong>findDevices</strong>(<a href="../chrome.usb/EnumerateDevicesAndRequestAccessOptions.html">EnumerateDevicesAndRequestAccessOptions</a> options) <a class="anchor-link" href="#findDevices"
              title="Permalink to ChromeUsb.findDevices">#</a></h4>
<div class="doc">
<p>Finds USB devices specified by the vendorId/productId/interfaceId tuple
and, if permissions allow, opens them for use.</p>
<p>On Chrome OS, you can specify the interfaceId. In that case the method will
request access from permission broker in the same way as in
<code>requestUsbAcess</code>.</p>
<p>If the access request is rejected, or the device is failed to be opened,
its connection handle will not be created or returned.</p>
<p>Calling this method is equivalent to calling <a class="crossref" href="../chrome.usb/ChromeUsb.html#getDevices">getDevices</a> followed by a
series of <a class="crossref" href="../chrome.usb/ChromeUsb.html#requestAccess">requestAccess</a> (if it is on ChromeOs) and <a class="crossref" href="../chrome.usb/ChromeUsb.html#openDevice">openDevice</a> calls,
and returning all the successfully opened connection handles.</p>
<p>
<span class="param">options</span>: The properties to search for on target devices.
<code>callback</code>: Invoked with the opened ConnectionHandle on complete.</p>
<pre class="source">
Future&lt;List&lt;ConnectionHandle&gt;&gt; findDevices(EnumerateDevicesAndRequestAccessOptions options) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;List&lt;ConnectionHandle&gt;&gt;.oneArg((e) =&gt; listify(e, _createConnectionHandle));
 _usb.callMethod('findDevices', [jsify(options), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getDevices">
<button class="show-code">Code</button>
Future&lt;List&lt;<a href="../chrome.usb/Device.html">Device</a>&gt;&gt; <strong>getDevices</strong>(<a href="../chrome.usb/EnumerateDevicesOptions.html">EnumerateDevicesOptions</a> options) <a class="anchor-link" href="#getDevices"
              title="Permalink to ChromeUsb.getDevices">#</a></h4>
<div class="doc">
<p>Lists USB devices specified by vendorId/productId/interfaceId tuple.

<span class="param">options</span>: The properties to search for on target devices.
<code>callback</code>: Invoked with a list of <a class="crossref" href="../chrome.usb/Device.html">Device</a>s on complete.</p>
<pre class="source">
Future&lt;List&lt;Device&gt;&gt; getDevices(EnumerateDevicesOptions options) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;List&lt;Device&gt;&gt;.oneArg((e) =&gt; listify(e, _createDevice));
 _usb.callMethod('getDevices', [jsify(options), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="interruptTransfer">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.usb/TransferResultInfo.html">TransferResultInfo</a>&gt; <strong>interruptTransfer</strong>(<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a> handle, <a href="../chrome.usb/GenericTransferInfo.html">GenericTransferInfo</a> transferInfo) <a class="anchor-link" href="#interruptTransfer"
              title="Permalink to ChromeUsb.interruptTransfer">#</a></h4>
<div class="doc">
<p>Performs an interrupt transfer on the specified device.

<span class="param">handle</span>: A connection handle to make the transfer on.

<span class="param">transferInfo</span>: The parameters to the transfer. See GenericTransferInfo.
<code>callback</code>: Invoked once the transfer has completed.</p>
<pre class="source">
Future&lt;TransferResultInfo&gt; interruptTransfer(ConnectionHandle handle, GenericTransferInfo transferInfo) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;TransferResultInfo&gt;.oneArg(_createTransferResultInfo);
 _usb.callMethod('interruptTransfer', [jsify(handle), jsify(transferInfo), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="isochronousTransfer">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.usb/TransferResultInfo.html">TransferResultInfo</a>&gt; <strong>isochronousTransfer</strong>(<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a> handle, <a href="../chrome.usb/IsochronousTransferInfo.html">IsochronousTransferInfo</a> transferInfo) <a class="anchor-link" href="#isochronousTransfer"
              title="Permalink to ChromeUsb.isochronousTransfer">#</a></h4>
<div class="doc">
<p>Performs an isochronous transfer on the specific device.

<span class="param">handle</span>: A connection handle to make the transfer on.

<span class="param">transferInfo</span>: The parameters to the transfer. See
IsochronousTransferInfo.
<code>callback</code>: Invoked once the transfer has been completed.</p>
<pre class="source">
Future&lt;TransferResultInfo&gt; isochronousTransfer(ConnectionHandle handle, IsochronousTransferInfo transferInfo) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;TransferResultInfo&gt;.oneArg(_createTransferResultInfo);
 _usb.callMethod('isochronousTransfer', [jsify(handle), jsify(transferInfo), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="listInterfaces">
<button class="show-code">Code</button>
Future&lt;List&lt;<a href="../chrome.usb/InterfaceDescriptor.html">InterfaceDescriptor</a>&gt;&gt; <strong>listInterfaces</strong>(<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a> handle) <a class="anchor-link" href="#listInterfaces"
              title="Permalink to ChromeUsb.listInterfaces">#</a></h4>
<div class="doc">
<p>Lists all the interfaces on the USB device.

<span class="param">handle</span>: The device from which the interfaces should be listed.
<code>callback</code>: The callback to invoke when the interfaces are enumerated.</p>
<pre class="source">
Future&lt;List&lt;InterfaceDescriptor&gt;&gt; listInterfaces(ConnectionHandle handle) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;List&lt;InterfaceDescriptor&gt;&gt;.oneArg((e) =&gt; listify(e, _createInterfaceDescriptor));
 _usb.callMethod('listInterfaces', [jsify(handle), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="openDevice">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a>&gt; <strong>openDevice</strong>(<a href="../chrome.usb/Device.html">Device</a> device) <a class="anchor-link" href="#openDevice"
              title="Permalink to ChromeUsb.openDevice">#</a></h4>
<div class="doc">
<p>Opens a USB device returned by <a class="crossref" href="../chrome.usb/ChromeUsb.html#getDevices">getDevices</a>.

<span class="param">device</span>: The device to open.
<code>callback</code>: Invoked with the created ConnectionHandle on complete.</p>
<pre class="source">
Future&lt;ConnectionHandle&gt; openDevice(Device device) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;ConnectionHandle&gt;.oneArg(_createConnectionHandle);
 _usb.callMethod('openDevice', [jsify(device), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="releaseInterface">
<button class="show-code">Code</button>
Future <strong>releaseInterface</strong>(<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a> handle, int interfaceNumber) <a class="anchor-link" href="#releaseInterface"
              title="Permalink to ChromeUsb.releaseInterface">#</a></h4>
<div class="doc">
<p>Releases a claim to an interface on the provided device.

<span class="param">handle</span>: The device on which the interface is to be released.
<code>interface</code>: The interface number to be released.
<code>callback</code>: The callback to invoke once the interface is released.</p>
<pre class="source">
Future releaseInterface(ConnectionHandle handle, int interfaceNumber) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _usb.callMethod('releaseInterface', [jsify(handle), interfaceNumber, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="requestAccess">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>requestAccess</strong>(<a href="../chrome.usb/Device.html">Device</a> device, int interfaceId) <a class="anchor-link" href="#requestAccess"
              title="Permalink to ChromeUsb.requestAccess">#</a></h4>
<div class="doc">
<p>This method is ChromeOS specific. Calling this method on other platforms
will fail. Requests access from the permission broker to an OS claimed
device if the given interface on the device is not claimed.</p>
<p>
<span class="param">device</span>: The device to request access to.

<span class="param">interfaceId</span>:</p>
<pre class="source">
Future&lt;bool&gt; requestAccess(Device device, int interfaceId) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
 _usb.callMethod('requestAccess', [jsify(device), interfaceId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="resetDevice">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>resetDevice</strong>(<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a> handle) <a class="anchor-link" href="#resetDevice"
              title="Permalink to ChromeUsb.resetDevice">#</a></h4>
<div class="doc">
<p>Tries to reset the USB device and restores it to the previous status. If
the reset fails, the given connection handle will be closed and the USB
device will appear to be disconnected then reconnected. In that case you
must call <a class="crossref" href="../chrome.usb/ChromeUsb.html#getDevices">getDevices</a> or <a class="crossref" href="../chrome.usb/ChromeUsb.html#findDevices">findDevices</a> again to acquire the device.</p>
<p>
<span class="param">handle</span>: A connection handle to reset.
<code>callback</code>: Invoked once the device is reset with a boolean indicating
whether the reset is completed successfully.</p>
<pre class="source">
Future&lt;bool&gt; resetDevice(ConnectionHandle handle) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
 _usb.callMethod('resetDevice', [jsify(handle), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setInterfaceAlternateSetting">
<button class="show-code">Code</button>
Future <strong>setInterfaceAlternateSetting</strong>(<a href="../chrome.usb/ConnectionHandle.html">ConnectionHandle</a> handle, int interfaceNumber, int alternateSetting) <a class="anchor-link" href="#setInterfaceAlternateSetting"
              title="Permalink to ChromeUsb.setInterfaceAlternateSetting">#</a></h4>
<div class="doc">
<p>Selects an alternate setting on a previously claimed interface on a device.

<span class="param">handle</span>: The device on which the interface settings are to be set.
<code>interface</code>: The interface number to be set.

<span class="param">alternateSetting</span>: The alternate setting to set.
<code>callback</code>: The callback to invoke once the interface setting is set.</p>
<pre class="source">
Future setInterfaceAlternateSetting(ConnectionHandle handle, int interfaceNumber, int alternateSetting) {
 if (_usb == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _usb.callMethod('setInterfaceAlternateSetting', [jsify(handle), interfaceNumber, alternateSetting, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        

        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ChromePushMessaging class / chrome.pushMessaging Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.pushMessaging" data-type="ChromePushMessaging">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.pushMessaging.html">chrome.pushMessaging</a> &rsaquo; <a href="../chrome.pushMessaging/ChromePushMessaging.html">ChromePushMessaging</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ChromePushMessaging</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class ChromePushMessaging extends ChromeApi {
 static final JsObject _pushMessaging = chrome['pushMessaging'];

 ChromePushMessaging._();

 bool get available =&gt; _pushMessaging != null;

 /**
  * Retrieves the channel ID associated with this app or extension. Typically
  * an app or extension will want to send this value to its application server
  * so the server can use it to trigger push messages back to the app or
  * extension. If the interactive flag is set, we will ask the user to log in
  * when they are not already logged in.
  */
 Future&lt;ChannelIdResult&gt; getChannelId([bool interactive]) {
   if (_pushMessaging == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;ChannelIdResult&gt;.oneArg(_createChannelIdResult);
   _pushMessaging.callMethod('getChannelId', [interactive, completer.callback]);
   return completer.future;
 }

 Stream&lt;Message&gt; get onMessage =&gt; _onMessage.stream;

 final ChromeStreamController&lt;Message&gt; _onMessage =
     new ChromeStreamController&lt;Message&gt;.oneArg(_pushMessaging, 'onMessage', _createMessage);

 void _throwNotAvailable() {
   throw new UnsupportedError("'chrome.pushMessaging' is not available");
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>ChromePushMessaging</strong></span></p>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="available">
<button class="show-code">Code</button>
final bool         <strong>available</strong> <a class="anchor-link"
            href="#available"
            title="Permalink to ChromePushMessaging.available">#</a>
        </h4>
        <div class="doc">
<div class="inherited">
<p>Returns true if the API is available. The common causes of an API not being
avilable are:</p><ul><li>a permission is missing in the application's manifest.json file</li><li>the API is defined on a newer version of Chrome then the current runtime</li></ul>
<div class="docs-inherited-from">docs inherited from <a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a> </div></div>
<pre class="source">
bool get available =&gt; _pushMessaging != null;
</pre>
</div>
</div>
<div class="field"><h4 id="onMessage">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.pushMessaging/Message.html">Message</a>&gt;         <strong>onMessage</strong> <a class="anchor-link"
            href="#onMessage"
            title="Permalink to ChromePushMessaging.onMessage">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;Message&gt; get onMessage =&gt; _onMessage.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="getChannelId">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.pushMessaging/ChannelIdResult.html">ChannelIdResult</a>&gt; <strong>getChannelId</strong>([bool interactive]) <a class="anchor-link" href="#getChannelId"
              title="Permalink to ChromePushMessaging.getChannelId">#</a></h4>
<div class="doc">
<p>Retrieves the channel ID associated with this app or extension. Typically
an app or extension will want to send this value to its application server
so the server can use it to trigger push messages back to the app or
extension. If the interactive flag is set, we will ask the user to log in
when they are not already logged in.</p>
<pre class="source">
Future&lt;ChannelIdResult&gt; getChannelId([bool interactive]) {
 if (_pushMessaging == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;ChannelIdResult&gt;.oneArg(_createChannelIdResult);
 _pushMessaging.callMethod('getChannelId', [interactive, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        

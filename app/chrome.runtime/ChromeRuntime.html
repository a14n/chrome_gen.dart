        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ChromeRuntime class / chrome.runtime Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.runtime" data-type="ChromeRuntime">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.runtime.html">chrome.runtime</a> &rsaquo; <a href="../chrome.runtime/ChromeRuntime.html">ChromeRuntime</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ChromeRuntime</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class ChromeRuntime extends ChromeApi {
 static final JsObject _runtime = chrome['runtime'];

 ChromeRuntime._();

 bool get available =&gt; _runtime != null;

 /**
  * This will be defined during an API method callback if there was an error
  */
 LastErrorRuntime get lastError =&gt; _createLastErrorRuntime(_runtime['lastError']);

 /**
  * The ID of the extension/app.
  */
 String get id =&gt; _runtime['id'];

 /**
  * Retrieves the JavaScript 'window' object for the background page running
  * inside the current extension/app. If the background page is an event page,
  * the system will ensure it is loaded before calling the callback. If there
  * is no background page, an error is set.
  * 
  * Returns:
  * The JavaScript 'window' object for the background page.
  */
 Future&lt;Window&gt; getBackgroundPage() {
   if (_runtime == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;Window&gt;.oneArg(_createWindow);
   _runtime.callMethod('getBackgroundPage', [completer.callback]);
   return completer.future;
 }

 /**
  * Returns details about the app or extension from the manifest. The object
  * returned is a serialization of the full [manifest file](manifest.html).
  * 
  * Returns:
  * The manifest details.
  */
 Map&lt;String, dynamic&gt; getManifest() {
   if (_runtime == null) _throwNotAvailable();

   return mapify(_runtime.callMethod('getManifest'));
 }

 /**
  * Converts a relative path within an app/extension install directory to a
  * fully-qualified URL.
  * 
  * [path] A path to a resource within an app/extension expressed relative to
  * its install directory.
  * 
  * Returns:
  * The fully-qualified URL to the resource.
  */
 String getURL(String path) {
   if (_runtime == null) _throwNotAvailable();

   return _runtime.callMethod('getURL', [path]);
 }

 /**
  * Sets the URL to be visited upon uninstallation. This may be used to clean
  * up server-side data, do analytics, and implement surveys. Maximum 255
  * characters.
  */
 void setUninstallUrl(String url) {
   if (_runtime == null) _throwNotAvailable();

   _runtime.callMethod('setUninstallUrl', [url]);
 }

 /**
  * Reloads the app or extension.
  */
 void reload() {
   if (_runtime == null) _throwNotAvailable();

   _runtime.callMethod('reload');
 }

 /**
  * Requests an update check for this app/extension.
  * 
  * Returns:
  * [status] Result of the update check.
  * enum of `throttled`, `no_update`, `update_available`
  * [details] If an update is available, this contains more information about
  * the available update.
  */
 Future&lt;RequestUpdateCheckResult&gt; requestUpdateCheck() {
   if (_runtime == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;RequestUpdateCheckResult&gt;.twoArgs(RequestUpdateCheckResult._create);
   _runtime.callMethod('requestUpdateCheck', [completer.callback]);
   return completer.future;
 }

 /**
  * Restart the ChromeOS device when the app runs in kiosk mode. Otherwise,
  * it's no-op.
  */
 void restart() {
   if (_runtime == null) _throwNotAvailable();

   _runtime.callMethod('restart');
 }

 /**
  * Attempts to connect to other listeners within the extension/app (such as
  * the background page), or other extensions/apps. This is useful for content
  * scripts connecting to their extension processes. Note that this does not
  * connect to any listeners in a content script. Extensions may connect to
  * content scripts embedded in tabs via [tabs.connect.]
  * 
  * [extensionId] The ID of the extension/app you want to connect to. If
  * omitted, default is your own extension.
  * 
  * Returns:
  * Port through which messages can be sent and received. The port's
  * [][runtime.Port onDisconnect] event is fired if the extension/app does not
  * exist.
  */
 Port connect([String extensionId, RuntimeConnectParams connectInfo]) {
   if (_runtime == null) _throwNotAvailable();

   return _createPort(_runtime.callMethod('connect', [extensionId, jsify(connectInfo)]));
 }

 /**
  * Connects to a native application in the host machine.
  * 
  * [application] The name of the registered application to connect to.
  * 
  * Returns:
  * Port through which messages can be sent and received with the application
  */
 Port connectNative(String application) {
   if (_runtime == null) _throwNotAvailable();

   return _createPort(_runtime.callMethod('connectNative', [application]));
 }

 /**
  * Sends a single message to onMessage event listeners within the extension
  * (or another extension/app). Similar to chrome.runtime.connect, but only
  * sends a single message with an optional response. The [runtime.onMessage]
  * event is fired in each extension page of the extension. Note that
  * extensions cannot send messages to content scripts using this method. To
  * send messages to content scripts, use [tabs.sendMessage.]
  * 
  * [extensionId] The extension ID of the extension you want to connect to. If
  * omitted, default is your own extension.
  * 
  * Returns:
  * The JSON response object sent by the handler of the message. If an error
  * occurs while connecting to the extension, the callback will be called with
  * no arguments and [runtime.lastError] will be set to the error message.
  */
 Future&lt;dynamic&gt; sendMessage(dynamic message, [String extensionId, RuntimeSendMessageParams options]) {
   if (_runtime == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;dynamic&gt;.oneArg();
   _runtime.callMethod('sendMessage', [extensionId, jsify(message), jsify(options), completer.callback]);
   return completer.future;
 }

 /**
  * Send a single message to a native application.
  * 
  * [application] The name of the native messaging host.
  * 
  * [message] The message that will be passed to the native messaging host.
  * 
  * Returns:
  * The response message send by the native messaging host. If an error occurs
  * while connecting to the native messaging host, the callback will be called
  * with no arguments and [runtime.lastError] will be set to the error message.
  */
 Future&lt;dynamic&gt; sendNativeMessage(String application, Map&lt;String, dynamic&gt; message) {
   if (_runtime == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;dynamic&gt;.oneArg();
   _runtime.callMethod('sendNativeMessage', [application, jsify(message), completer.callback]);
   return completer.future;
 }

 /**
  * Returns information about the current platform.
  */
 Future&lt;Map&gt; getPlatformInfo() {
   if (_runtime == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;Map&gt;.oneArg(mapify);
   _runtime.callMethod('getPlatformInfo', [completer.callback]);
   return completer.future;
 }

 /**
  * Returns a DirectoryEntry for the package directory.
  */
 Future&lt;DirectoryEntry&gt; getPackageDirectoryEntry() {
   if (_runtime == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;DirectoryEntry&gt;.oneArg(_createDirectoryEntry);
   _runtime.callMethod('getPackageDirectoryEntry', [completer.callback]);
   return completer.future;
 }

 /**
  * Fired when a profile that has this extension installed first starts up.
  * This event is not fired when an incognito profile is started, even if this
  * extension is operating in 'split' incognito mode.
  */
 Stream get onStartup =&gt; _onStartup.stream;

 final ChromeStreamController _onStartup =
     new ChromeStreamController.noArgs(_runtime, 'onStartup');

 /**
  * Fired when the extension is first installed, when the extension is updated
  * to a new version, and when Chrome is updated to a new version.
  */
 Stream&lt;Map&gt; get onInstalled =&gt; _onInstalled.stream;

 final ChromeStreamController&lt;Map&gt; _onInstalled =
     new ChromeStreamController&lt;Map&gt;.oneArg(_runtime, 'onInstalled', mapify);

 /**
  * Sent to the event page just before it is unloaded. This gives the extension
  * opportunity to do some clean up. Note that since the page is unloading, any
  * asynchronous operations started while handling this event are not
  * guaranteed to complete. If more activity for the event page occurs before
  * it gets unloaded the onSuspendCanceled event will be sent and the page
  * won't be unloaded.
  */
 Stream get onSuspend =&gt; _onSuspend.stream;

 final ChromeStreamController _onSuspend =
     new ChromeStreamController.noArgs(_runtime, 'onSuspend');

 /**
  * Sent after onSuspend to indicate that the app won't be unloaded after all.
  */
 Stream get onSuspendCanceled =&gt; _onSuspendCanceled.stream;

 final ChromeStreamController _onSuspendCanceled =
     new ChromeStreamController.noArgs(_runtime, 'onSuspendCanceled');

 /**
  * Fired when an update is available, but isn't installed immediately because
  * the app is currently running. If you do nothing, the update will be
  * installed the next time the background page gets unloaded, if you want it
  * to be installed sooner you can explicitly call chrome.runtime.reload().
  */
 Stream&lt;Map&lt;String, dynamic&gt;&gt; get onUpdateAvailable =&gt; _onUpdateAvailable.stream;

 final ChromeStreamController&lt;Map&lt;String, dynamic&gt;&gt; _onUpdateAvailable =
     new ChromeStreamController&lt;Map&lt;String, dynamic&gt;&gt;.oneArg(_runtime, 'onUpdateAvailable', mapify);

 /**
  * Fired when a Chrome update is available, but isn't installed immediately
  * because a browser restart is required.
  */
 Stream get onBrowserUpdateAvailable =&gt; _onBrowserUpdateAvailable.stream;

 final ChromeStreamController _onBrowserUpdateAvailable =
     new ChromeStreamController.noArgs(_runtime, 'onBrowserUpdateAvailable');

 /**
  * Fired when a connection is made from either an extension process or a
  * content script.
  */
 Stream&lt;Port&gt; get onConnect =&gt; _onConnect.stream;

 final ChromeStreamController&lt;Port&gt; _onConnect =
     new ChromeStreamController&lt;Port&gt;.oneArg(_runtime, 'onConnect', _createPort);

 /**
  * Fired when a connection is made from another extension.
  */
 Stream&lt;Port&gt; get onConnectExternal =&gt; _onConnectExternal.stream;

 final ChromeStreamController&lt;Port&gt; _onConnectExternal =
     new ChromeStreamController&lt;Port&gt;.oneArg(_runtime, 'onConnectExternal', _createPort);

 /**
  * Fired when a message is sent from either an extension process or a content
  * script.
  */
 Stream&lt;OnMessageEvent&gt; get onMessage =&gt; _onMessage.stream;

 final ChromeStreamController&lt;OnMessageEvent&gt; _onMessage =
     new ChromeStreamController&lt;OnMessageEvent&gt;.threeArgs(_runtime, 'onMessage', _createOnMessageEvent);

 /**
  * Fired when a message is sent from another extension/app. Cannot be used in
  * a content script.
  */
 Stream&lt;OnMessageExternalEvent&gt; get onMessageExternal =&gt; _onMessageExternal.stream;

 final ChromeStreamController&lt;OnMessageExternalEvent&gt; _onMessageExternal =
     new ChromeStreamController&lt;OnMessageExternalEvent&gt;.threeArgs(_runtime, 'onMessageExternal', _createOnMessageExternalEvent);

 /**
  * Fired when an app or the device that it runs on needs to be restarted. The
  * app should close all its windows at its earliest convenient time to let the
  * restart to happen. If the app does nothing, a restart will be enforced
  * after a 24-hour grace period has passed. Currently, this event is only
  * fired for Chrome OS kiosk apps.
  */
 Stream&lt;String&gt; get onRestartRequired =&gt; _onRestartRequired.stream;

 final ChromeStreamController&lt;String&gt; _onRestartRequired =
     new ChromeStreamController&lt;String&gt;.oneArg(_runtime, 'onRestartRequired', selfConverter);

 void _throwNotAvailable() {
   throw new UnsupportedError("'chrome.runtime' is not available");
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>ChromeRuntime</strong></span></p>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="available">
<button class="show-code">Code</button>
final bool         <strong>available</strong> <a class="anchor-link"
            href="#available"
            title="Permalink to ChromeRuntime.available">#</a>
        </h4>
        <div class="doc">
<div class="inherited">
<p>Returns true if the API is available. The common causes of an API not being
avilable are:</p><ul><li>a permission is missing in the application's manifest.json file</li><li>the API is defined on a newer version of Chrome then the current runtime</li></ul>
<div class="docs-inherited-from">docs inherited from <a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a> </div></div>
<pre class="source">
bool get available =&gt; _runtime != null;
</pre>
</div>
</div>
<div class="field"><h4 id="id">
<button class="show-code">Code</button>
final String         <strong>id</strong> <a class="anchor-link"
            href="#id"
            title="Permalink to ChromeRuntime.id">#</a>
        </h4>
        <div class="doc">
<p>The ID of the extension/app.</p>
<pre class="source">
String get id =&gt; _runtime['id'];
</pre>
</div>
</div>
<div class="field"><h4 id="lastError">
<button class="show-code">Code</button>
final <a href="../chrome.runtime/LastErrorRuntime.html">LastErrorRuntime</a>         <strong>lastError</strong> <a class="anchor-link"
            href="#lastError"
            title="Permalink to ChromeRuntime.lastError">#</a>
        </h4>
        <div class="doc">
<p>This will be defined during an API method callback if there was an error</p>
<pre class="source">
LastErrorRuntime get lastError =&gt; _createLastErrorRuntime(_runtime['lastError']);
</pre>
</div>
</div>
<div class="field"><h4 id="onBrowserUpdateAvailable">
<button class="show-code">Code</button>
final Stream         <strong>onBrowserUpdateAvailable</strong> <a class="anchor-link"
            href="#onBrowserUpdateAvailable"
            title="Permalink to ChromeRuntime.onBrowserUpdateAvailable">#</a>
        </h4>
        <div class="doc">
<p>Fired when a Chrome update is available, but isn't installed immediately
because a browser restart is required.</p>
<pre class="source">
Stream get onBrowserUpdateAvailable =&gt; _onBrowserUpdateAvailable.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onConnect">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.runtime/Port.html">Port</a>&gt;         <strong>onConnect</strong> <a class="anchor-link"
            href="#onConnect"
            title="Permalink to ChromeRuntime.onConnect">#</a>
        </h4>
        <div class="doc">
<p>Fired when a connection is made from either an extension process or a
content script.</p>
<pre class="source">
Stream&lt;Port&gt; get onConnect =&gt; _onConnect.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onConnectExternal">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.runtime/Port.html">Port</a>&gt;         <strong>onConnectExternal</strong> <a class="anchor-link"
            href="#onConnectExternal"
            title="Permalink to ChromeRuntime.onConnectExternal">#</a>
        </h4>
        <div class="doc">
<p>Fired when a connection is made from another extension.</p>
<pre class="source">
Stream&lt;Port&gt; get onConnectExternal =&gt; _onConnectExternal.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onInstalled">
<button class="show-code">Code</button>
final Stream&lt;Map&gt;         <strong>onInstalled</strong> <a class="anchor-link"
            href="#onInstalled"
            title="Permalink to ChromeRuntime.onInstalled">#</a>
        </h4>
        <div class="doc">
<p>Fired when the extension is first installed, when the extension is updated
to a new version, and when Chrome is updated to a new version.</p>
<pre class="source">
Stream&lt;Map&gt; get onInstalled =&gt; _onInstalled.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onMessage">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.runtime/OnMessageEvent.html">OnMessageEvent</a>&gt;         <strong>onMessage</strong> <a class="anchor-link"
            href="#onMessage"
            title="Permalink to ChromeRuntime.onMessage">#</a>
        </h4>
        <div class="doc">
<p>Fired when a message is sent from either an extension process or a content
script.</p>
<pre class="source">
Stream&lt;OnMessageEvent&gt; get onMessage =&gt; _onMessage.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onMessageExternal">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.runtime/OnMessageExternalEvent.html">OnMessageExternalEvent</a>&gt;         <strong>onMessageExternal</strong> <a class="anchor-link"
            href="#onMessageExternal"
            title="Permalink to ChromeRuntime.onMessageExternal">#</a>
        </h4>
        <div class="doc">
<p>Fired when a message is sent from another extension/app. Cannot be used in
a content script.</p>
<pre class="source">
Stream&lt;OnMessageExternalEvent&gt; get onMessageExternal =&gt; _onMessageExternal.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onRestartRequired">
<button class="show-code">Code</button>
final Stream&lt;String&gt;         <strong>onRestartRequired</strong> <a class="anchor-link"
            href="#onRestartRequired"
            title="Permalink to ChromeRuntime.onRestartRequired">#</a>
        </h4>
        <div class="doc">
<p>Fired when an app or the device that it runs on needs to be restarted. The
app should close all its windows at its earliest convenient time to let the
restart to happen. If the app does nothing, a restart will be enforced
after a 24-hour grace period has passed. Currently, this event is only
fired for Chrome OS kiosk apps.</p>
<pre class="source">
Stream&lt;String&gt; get onRestartRequired =&gt; _onRestartRequired.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onStartup">
<button class="show-code">Code</button>
final Stream         <strong>onStartup</strong> <a class="anchor-link"
            href="#onStartup"
            title="Permalink to ChromeRuntime.onStartup">#</a>
        </h4>
        <div class="doc">
<p>Fired when a profile that has this extension installed first starts up.
This event is not fired when an incognito profile is started, even if this
extension is operating in 'split' incognito mode.</p>
<pre class="source">
Stream get onStartup =&gt; _onStartup.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onSuspend">
<button class="show-code">Code</button>
final Stream         <strong>onSuspend</strong> <a class="anchor-link"
            href="#onSuspend"
            title="Permalink to ChromeRuntime.onSuspend">#</a>
        </h4>
        <div class="doc">
<p>Sent to the event page just before it is unloaded. This gives the extension
opportunity to do some clean up. Note that since the page is unloading, any
asynchronous operations started while handling this event are not
guaranteed to complete. If more activity for the event page occurs before
it gets unloaded the onSuspendCanceled event will be sent and the page
won't be unloaded.</p>
<pre class="source">
Stream get onSuspend =&gt; _onSuspend.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onSuspendCanceled">
<button class="show-code">Code</button>
final Stream         <strong>onSuspendCanceled</strong> <a class="anchor-link"
            href="#onSuspendCanceled"
            title="Permalink to ChromeRuntime.onSuspendCanceled">#</a>
        </h4>
        <div class="doc">
<p>Sent after onSuspend to indicate that the app won't be unloaded after all.</p>
<pre class="source">
Stream get onSuspendCanceled =&gt; _onSuspendCanceled.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onUpdateAvailable">
<button class="show-code">Code</button>
final Stream&lt;Map&lt;String, dynamic&gt;&gt;         <strong>onUpdateAvailable</strong> <a class="anchor-link"
            href="#onUpdateAvailable"
            title="Permalink to ChromeRuntime.onUpdateAvailable">#</a>
        </h4>
        <div class="doc">
<p>Fired when an update is available, but isn't installed immediately because
the app is currently running. If you do nothing, the update will be
installed the next time the background page gets unloaded, if you want it
to be installed sooner you can explicitly call chrome.runtime.reload().</p>
<pre class="source">
Stream&lt;Map&lt;String, dynamic&gt;&gt; get onUpdateAvailable =&gt; _onUpdateAvailable.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="connect">
<button class="show-code">Code</button>
<a href="../chrome.runtime/Port.html">Port</a> <strong>connect</strong>([String extensionId, <a href="../chrome.runtime/RuntimeConnectParams.html">RuntimeConnectParams</a> connectInfo]) <a class="anchor-link" href="#connect"
              title="Permalink to ChromeRuntime.connect">#</a></h4>
<div class="doc">
<p>Attempts to connect to other listeners within the extension/app (such as
the background page), or other extensions/apps. This is useful for content
scripts connecting to their extension processes. Note that this does not
connect to any listeners in a content script. Extensions may connect to
content scripts embedded in tabs via <code>tabs.connect.</code></p>
<p>
<span class="param">extensionId</span> The ID of the extension/app you want to connect to. If
omitted, default is your own extension.</p>
<p>Returns:
Port through which messages can be sent and received. The port's
[][runtime.Port onDisconnect] event is fired if the extension/app does not
exist.</p>
<pre class="source">
Port connect([String extensionId, RuntimeConnectParams connectInfo]) {
 if (_runtime == null) _throwNotAvailable();

 return _createPort(_runtime.callMethod('connect', [extensionId, jsify(connectInfo)]));
}
</pre>
</div>
</div>
<div class="method"><h4 id="connectNative">
<button class="show-code">Code</button>
<a href="../chrome.runtime/Port.html">Port</a> <strong>connectNative</strong>(String application) <a class="anchor-link" href="#connectNative"
              title="Permalink to ChromeRuntime.connectNative">#</a></h4>
<div class="doc">
<p>Connects to a native application in the host machine.</p>
<p>
<span class="param">application</span> The name of the registered application to connect to.</p>
<p>Returns:
Port through which messages can be sent and received with the application</p>
<pre class="source">
Port connectNative(String application) {
 if (_runtime == null) _throwNotAvailable();

 return _createPort(_runtime.callMethod('connectNative', [application]));
}
</pre>
</div>
</div>
<div class="method"><h4 id="getBackgroundPage">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.windows/Window.html">Window</a>&gt; <strong>getBackgroundPage</strong>() <a class="anchor-link" href="#getBackgroundPage"
              title="Permalink to ChromeRuntime.getBackgroundPage">#</a></h4>
<div class="doc">
<p>Retrieves the JavaScript 'window' object for the background page running
inside the current extension/app. If the background page is an event page,
the system will ensure it is loaded before calling the callback. If there
is no background page, an error is set.</p>
<p>Returns:
The JavaScript 'window' object for the background page.</p>
<pre class="source">
Future&lt;Window&gt; getBackgroundPage() {
 if (_runtime == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;Window&gt;.oneArg(_createWindow);
 _runtime.callMethod('getBackgroundPage', [completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getManifest">
<button class="show-code">Code</button>
Map&lt;String, dynamic&gt; <strong>getManifest</strong>() <a class="anchor-link" href="#getManifest"
              title="Permalink to ChromeRuntime.getManifest">#</a></h4>
<div class="doc">
<p>Returns details about the app or extension from the manifest. The object
returned is a serialization of the full <a href="manifest.html">manifest file</a>.</p>
<p>Returns:
The manifest details.</p>
<pre class="source">
Map&lt;String, dynamic&gt; getManifest() {
 if (_runtime == null) _throwNotAvailable();

 return mapify(_runtime.callMethod('getManifest'));
}
</pre>
</div>
</div>
<div class="method"><h4 id="getPackageDirectoryEntry">
<button class="show-code">Code</button>
Future&lt;DirectoryEntry&gt; <strong>getPackageDirectoryEntry</strong>() <a class="anchor-link" href="#getPackageDirectoryEntry"
              title="Permalink to ChromeRuntime.getPackageDirectoryEntry">#</a></h4>
<div class="doc">
<p>Returns a DirectoryEntry for the package directory.</p>
<pre class="source">
Future&lt;DirectoryEntry&gt; getPackageDirectoryEntry() {
 if (_runtime == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;DirectoryEntry&gt;.oneArg(_createDirectoryEntry);
 _runtime.callMethod('getPackageDirectoryEntry', [completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getPlatformInfo">
<button class="show-code">Code</button>
Future&lt;Map&gt; <strong>getPlatformInfo</strong>() <a class="anchor-link" href="#getPlatformInfo"
              title="Permalink to ChromeRuntime.getPlatformInfo">#</a></h4>
<div class="doc">
<p>Returns information about the current platform.</p>
<pre class="source">
Future&lt;Map&gt; getPlatformInfo() {
 if (_runtime == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;Map&gt;.oneArg(mapify);
 _runtime.callMethod('getPlatformInfo', [completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getURL">
<button class="show-code">Code</button>
String <strong>getURL</strong>(String path) <a class="anchor-link" href="#getURL"
              title="Permalink to ChromeRuntime.getURL">#</a></h4>
<div class="doc">
<p>Converts a relative path within an app/extension install directory to a
fully-qualified URL.</p>
<p>
<span class="param">path</span> A path to a resource within an app/extension expressed relative to
its install directory.</p>
<p>Returns:
The fully-qualified URL to the resource.</p>
<pre class="source">
String getURL(String path) {
 if (_runtime == null) _throwNotAvailable();

 return _runtime.callMethod('getURL', [path]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="reload">
<button class="show-code">Code</button>
void <strong>reload</strong>() <a class="anchor-link" href="#reload"
              title="Permalink to ChromeRuntime.reload">#</a></h4>
<div class="doc">
<p>Reloads the app or extension.</p>
<pre class="source">
void reload() {
 if (_runtime == null) _throwNotAvailable();

 _runtime.callMethod('reload');
}
</pre>
</div>
</div>
<div class="method"><h4 id="requestUpdateCheck">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.runtime/RequestUpdateCheckResult.html">RequestUpdateCheckResult</a>&gt; <strong>requestUpdateCheck</strong>() <a class="anchor-link" href="#requestUpdateCheck"
              title="Permalink to ChromeRuntime.requestUpdateCheck">#</a></h4>
<div class="doc">
<p>Requests an update check for this app/extension.</p>
<p>Returns:
<code>status</code> Result of the update check.
enum of <code>throttled</code>, <code>no_update</code>, <code>update_available</code>
<code>details</code> If an update is available, this contains more information about
the available update.</p>
<pre class="source">
Future&lt;RequestUpdateCheckResult&gt; requestUpdateCheck() {
 if (_runtime == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;RequestUpdateCheckResult&gt;.twoArgs(RequestUpdateCheckResult._create);
 _runtime.callMethod('requestUpdateCheck', [completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="restart">
<button class="show-code">Code</button>
void <strong>restart</strong>() <a class="anchor-link" href="#restart"
              title="Permalink to ChromeRuntime.restart">#</a></h4>
<div class="doc">
<p>Restart the ChromeOS device when the app runs in kiosk mode. Otherwise,
it's no-op.</p>
<pre class="source">
void restart() {
 if (_runtime == null) _throwNotAvailable();

 _runtime.callMethod('restart');
}
</pre>
</div>
</div>
<div class="method"><h4 id="sendMessage">
<button class="show-code">Code</button>
Future&lt;dynamic&gt; <strong>sendMessage</strong>(message, [String extensionId, <a href="../chrome.runtime/RuntimeSendMessageParams.html">RuntimeSendMessageParams</a> options]) <a class="anchor-link" href="#sendMessage"
              title="Permalink to ChromeRuntime.sendMessage">#</a></h4>
<div class="doc">
<p>Sends a single message to onMessage event listeners within the extension
(or another extension/app). Similar to chrome.runtime.connect, but only
sends a single message with an optional response. The <code>runtime.onMessage</code>
event is fired in each extension page of the extension. Note that
extensions cannot send messages to content scripts using this method. To
send messages to content scripts, use <code>tabs.sendMessage.</code></p>
<p>
<span class="param">extensionId</span> The extension ID of the extension you want to connect to. If
omitted, default is your own extension.</p>
<p>Returns:
The JSON response object sent by the handler of the message. If an error
occurs while connecting to the extension, the callback will be called with
no arguments and <code>runtime.lastError</code> will be set to the error message.</p>
<pre class="source">
Future&lt;dynamic&gt; sendMessage(dynamic message, [String extensionId, RuntimeSendMessageParams options]) {
 if (_runtime == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;dynamic&gt;.oneArg();
 _runtime.callMethod('sendMessage', [extensionId, jsify(message), jsify(options), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="sendNativeMessage">
<button class="show-code">Code</button>
Future&lt;dynamic&gt; <strong>sendNativeMessage</strong>(String application, Map&lt;String, dynamic&gt; message) <a class="anchor-link" href="#sendNativeMessage"
              title="Permalink to ChromeRuntime.sendNativeMessage">#</a></h4>
<div class="doc">
<p>Send a single message to a native application.</p>
<p>
<span class="param">application</span> The name of the native messaging host.</p>
<p>
<span class="param">message</span> The message that will be passed to the native messaging host.</p>
<p>Returns:
The response message send by the native messaging host. If an error occurs
while connecting to the native messaging host, the callback will be called
with no arguments and <code>runtime.lastError</code> will be set to the error message.</p>
<pre class="source">
Future&lt;dynamic&gt; sendNativeMessage(String application, Map&lt;String, dynamic&gt; message) {
 if (_runtime == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;dynamic&gt;.oneArg();
 _runtime.callMethod('sendNativeMessage', [application, jsify(message), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setUninstallUrl">
<button class="show-code">Code</button>
void <strong>setUninstallUrl</strong>(String url) <a class="anchor-link" href="#setUninstallUrl"
              title="Permalink to ChromeRuntime.setUninstallUrl">#</a></h4>
<div class="doc">
<p>Sets the URL to be visited upon uninstallation. This may be used to clean
up server-side data, do analytics, and implement surveys. Maximum 255
characters.</p>
<pre class="source">
void setUninstallUrl(String url) {
 if (_runtime == null) _throwNotAvailable();

 _runtime.callMethod('setUninstallUrl', [url]);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        

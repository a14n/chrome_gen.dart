        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ChromeProcesses class / chrome.processes Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.processes" data-type="ChromeProcesses">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.processes.html">chrome.processes</a> &rsaquo; <a href="../chrome.processes/ChromeProcesses.html">ChromeProcesses</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ChromeProcesses</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class ChromeProcesses extends ChromeApi {
 static final JsObject _processes = chrome['processes'];

 ChromeProcesses._();

 bool get available =&gt; _processes != null;

 /**
  * Terminates the specified renderer process. Equivalent to visiting
  * about:crash, but without changing the tab's URL.
  * 
  * [processId] The ID of the process to be terminated.
  * 
  * Returns:
  * True if terminating the process was successful, otherwise false.
  */
 Future&lt;bool&gt; terminate(int processId) {
   if (_processes == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
   _processes.callMethod('terminate', [processId, completer.callback]);
   return completer.future;
 }

 /**
  * Returns the ID of the renderer process for the specified tab.
  * 
  * [tabId] The ID of the tab for which the renderer process ID is to be
  * returned.
  * 
  * Returns:
  * Process ID of the tab's renderer process.
  */
 Future&lt;int&gt; getProcessIdForTab(int tabId) {
   if (_processes == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;int&gt;.oneArg();
   _processes.callMethod('getProcessIdForTab', [tabId, completer.callback]);
   return completer.future;
 }

 /**
  * Retrieves the process information for each process ID specified.
  * 
  * [processIds] The list of process IDs or single process ID for which to
  * return the process information. An empty list indicates all processes are
  * requested.
  * 
  * [includeMemory] True if detailed memory usage is required. Note, collecting
  * memory usage information incurs extra CPU usage and should only be queried
  * for when needed.
  * 
  * Returns:
  * A dictionary of Process objects for each requested process that is a live
  * child process of the current browser process, indexed by process ID.
  * Metrics requiring aggregation over time will not be populated in each
  * Process object.
  */
 Future&lt;Map&gt; getProcessInfo(dynamic processIds, bool includeMemory) {
   if (_processes == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;Map&gt;.oneArg(mapify);
   _processes.callMethod('getProcessInfo', [jsify(processIds), includeMemory, completer.callback]);
   return completer.future;
 }

 /**
  * Fired each time the Task Manager updates its process statistics, providing
  * the dictionary of updated Process objects, indexed by process ID.
  */
 Stream&lt;Map&gt; get onUpdated =&gt; _onUpdated.stream;

 final ChromeStreamController&lt;Map&gt; _onUpdated =
     new ChromeStreamController&lt;Map&gt;.oneArg(_processes, 'onUpdated', mapify);

 /**
  * Fired each time the Task Manager updates its process statistics, providing
  * the dictionary of updated Process objects, indexed by process ID. Identical
  * to onUpdate, with the addition of memory usage details included in each
  * Process object. Note, collecting memory usage information incurs extra CPU
  * usage and should only be listened for when needed.
  */
 Stream&lt;Map&gt; get onUpdatedWithMemory =&gt; _onUpdatedWithMemory.stream;

 final ChromeStreamController&lt;Map&gt; _onUpdatedWithMemory =
     new ChromeStreamController&lt;Map&gt;.oneArg(_processes, 'onUpdatedWithMemory', mapify);

 /**
  * Fired each time a process is created, providing the corrseponding Process
  * object.
  */
 Stream&lt;Process&gt; get onCreated =&gt; _onCreated.stream;

 final ChromeStreamController&lt;Process&gt; _onCreated =
     new ChromeStreamController&lt;Process&gt;.oneArg(_processes, 'onCreated', _createProcess);

 /**
  * Fired each time a process becomes unresponsive, providing the corrseponding
  * Process object.
  */
 Stream&lt;Process&gt; get onUnresponsive =&gt; _onUnresponsive.stream;

 final ChromeStreamController&lt;Process&gt; _onUnresponsive =
     new ChromeStreamController&lt;Process&gt;.oneArg(_processes, 'onUnresponsive', _createProcess);

 /**
  * Fired each time a process is terminated, providing the type of exit.
  */
 Stream&lt;OnExitedEvent&gt; get onExited =&gt; _onExited.stream;

 final ChromeStreamController&lt;OnExitedEvent&gt; _onExited =
     new ChromeStreamController&lt;OnExitedEvent&gt;.threeArgs(_processes, 'onExited', _createOnExitedEvent);

 void _throwNotAvailable() {
   throw new UnsupportedError("'chrome.processes' is not available");
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>ChromeProcesses</strong></span></p>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="available">
<button class="show-code">Code</button>
final bool         <strong>available</strong> <a class="anchor-link"
            href="#available"
            title="Permalink to ChromeProcesses.available">#</a>
        </h4>
        <div class="doc">
<div class="inherited">
<p>Returns true if the API is available. The common causes of an API not being
avilable are:</p><ul><li>a permission is missing in the application's manifest.json file</li><li>the API is defined on a newer version of Chrome then the current runtime</li></ul>
<div class="docs-inherited-from">docs inherited from <a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a> </div></div>
<pre class="source">
bool get available =&gt; _processes != null;
</pre>
</div>
</div>
<div class="field"><h4 id="onCreated">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.processes/Process.html">Process</a>&gt;         <strong>onCreated</strong> <a class="anchor-link"
            href="#onCreated"
            title="Permalink to ChromeProcesses.onCreated">#</a>
        </h4>
        <div class="doc">
<p>Fired each time a process is created, providing the corrseponding Process
object.</p>
<pre class="source">
Stream&lt;Process&gt; get onCreated =&gt; _onCreated.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onExited">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.processes/OnExitedEvent.html">OnExitedEvent</a>&gt;         <strong>onExited</strong> <a class="anchor-link"
            href="#onExited"
            title="Permalink to ChromeProcesses.onExited">#</a>
        </h4>
        <div class="doc">
<p>Fired each time a process is terminated, providing the type of exit.</p>
<pre class="source">
Stream&lt;OnExitedEvent&gt; get onExited =&gt; _onExited.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onUnresponsive">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.processes/Process.html">Process</a>&gt;         <strong>onUnresponsive</strong> <a class="anchor-link"
            href="#onUnresponsive"
            title="Permalink to ChromeProcesses.onUnresponsive">#</a>
        </h4>
        <div class="doc">
<p>Fired each time a process becomes unresponsive, providing the corrseponding
Process object.</p>
<pre class="source">
Stream&lt;Process&gt; get onUnresponsive =&gt; _onUnresponsive.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onUpdated">
<button class="show-code">Code</button>
final Stream&lt;Map&gt;         <strong>onUpdated</strong> <a class="anchor-link"
            href="#onUpdated"
            title="Permalink to ChromeProcesses.onUpdated">#</a>
        </h4>
        <div class="doc">
<p>Fired each time the Task Manager updates its process statistics, providing
the dictionary of updated Process objects, indexed by process ID.</p>
<pre class="source">
Stream&lt;Map&gt; get onUpdated =&gt; _onUpdated.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onUpdatedWithMemory">
<button class="show-code">Code</button>
final Stream&lt;Map&gt;         <strong>onUpdatedWithMemory</strong> <a class="anchor-link"
            href="#onUpdatedWithMemory"
            title="Permalink to ChromeProcesses.onUpdatedWithMemory">#</a>
        </h4>
        <div class="doc">
<p>Fired each time the Task Manager updates its process statistics, providing
the dictionary of updated Process objects, indexed by process ID. Identical
to onUpdate, with the addition of memory usage details included in each
Process object. Note, collecting memory usage information incurs extra CPU
usage and should only be listened for when needed.</p>
<pre class="source">
Stream&lt;Map&gt; get onUpdatedWithMemory =&gt; _onUpdatedWithMemory.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="getProcessIdForTab">
<button class="show-code">Code</button>
Future&lt;int&gt; <strong>getProcessIdForTab</strong>(int tabId) <a class="anchor-link" href="#getProcessIdForTab"
              title="Permalink to ChromeProcesses.getProcessIdForTab">#</a></h4>
<div class="doc">
<p>Returns the ID of the renderer process for the specified tab.</p>
<p>
<span class="param">tabId</span> The ID of the tab for which the renderer process ID is to be
returned.</p>
<p>Returns:
Process ID of the tab's renderer process.</p>
<pre class="source">
Future&lt;int&gt; getProcessIdForTab(int tabId) {
 if (_processes == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;int&gt;.oneArg();
 _processes.callMethod('getProcessIdForTab', [tabId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getProcessInfo">
<button class="show-code">Code</button>
Future&lt;Map&gt; <strong>getProcessInfo</strong>(processIds, bool includeMemory) <a class="anchor-link" href="#getProcessInfo"
              title="Permalink to ChromeProcesses.getProcessInfo">#</a></h4>
<div class="doc">
<p>Retrieves the process information for each process ID specified.</p>
<p>
<span class="param">processIds</span> The list of process IDs or single process ID for which to
return the process information. An empty list indicates all processes are
requested.</p>
<p>
<span class="param">includeMemory</span> True if detailed memory usage is required. Note, collecting
memory usage information incurs extra CPU usage and should only be queried
for when needed.</p>
<p>Returns:
A dictionary of Process objects for each requested process that is a live
child process of the current browser process, indexed by process ID.
Metrics requiring aggregation over time will not be populated in each
Process object.</p>
<pre class="source">
Future&lt;Map&gt; getProcessInfo(dynamic processIds, bool includeMemory) {
 if (_processes == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;Map&gt;.oneArg(mapify);
 _processes.callMethod('getProcessInfo', [jsify(processIds), includeMemory, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="terminate">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>terminate</strong>(int processId) <a class="anchor-link" href="#terminate"
              title="Permalink to ChromeProcesses.terminate">#</a></h4>
<div class="doc">
<p>Terminates the specified renderer process. Equivalent to visiting
about:crash, but without changing the tab's URL.</p>
<p>
<span class="param">processId</span> The ID of the process to be terminated.</p>
<p>Returns:
True if terminating the process was successful, otherwise false.</p>
<pre class="source">
Future&lt;bool&gt; terminate(int processId) {
 if (_processes == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;bool&gt;.oneArg();
 _processes.callMethod('terminate', [processId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        

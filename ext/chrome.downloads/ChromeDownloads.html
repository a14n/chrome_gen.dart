        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ChromeDownloads class / chrome.downloads Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.downloads" data-type="ChromeDownloads">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.downloads.html">chrome.downloads</a> &rsaquo; <a href="../chrome.downloads/ChromeDownloads.html">ChromeDownloads</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ChromeDownloads</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class ChromeDownloads {
 static final JsObject _downloads = context['chrome']['downloads'];

 ChromeDownloads._();

 /**
  * Download a URL. If the URL uses the HTTP[S] protocol, then the request will
  * include all cookies currently set for its hostname. If both `filename` and
  * `saveAs` are specified, then the Save As dialog will be displayed,
  * pre-populated with the specified `filename`. If the download started
  * successfully, `callback` will be called with the new $ref:DownloadItem's
  * `downloadId`. If there was an error starting the download, then `callback`
  * will be called with `downloadId=undefined` and $ref:runtime.lastError will
  * contain a descriptive string. The error strings are not guaranteed to
  * remain backwards compatible between releases. Extensions must not parse it.
  * [options]: What to download and how.
  * [callback]: Called with the id of the new $ref:DownloadItem.
  */
 Future&lt;int&gt; download(DownloadOptions options) {
   var completer = new ChromeCompleter&lt;int&gt;.oneArg();
   _downloads.callMethod('download', [options, completer.callback]);
   return completer.future;
 }

 /**
  * Find $ref:DownloadItem. Set `query` to the empty object to get all
  * $ref:DownloadItem. To get a specific $ref:DownloadItem, set only the `id`
  * field. To page through a large number of items, set `orderBy:
  * ['-startTime']`, set `limit` to the number of items per page, and set
  * `startedAfter` to the `startTime` of the last item from the last page.
  */
 Future&lt;DownloadItem&gt; search(DownloadQuery query) {
   var completer = new ChromeCompleter&lt;DownloadItem&gt;.oneArg(_createDownloadItem);
   _downloads.callMethod('search', [query, completer.callback]);
   return completer.future;
 }

 /**
  * Pause the download. If the request was successful the download is in a
  * paused state. Otherwise $ref:runtime.lastError contains an error message.
  * The request will fail if the download is not active.
  * [downloadId]: The id of the download to pause.
  * [callback]: Called when the pause request is completed.
  */
 Future pause(int downloadId) {
   var completer = new ChromeCompleter.noArgs();
   _downloads.callMethod('pause', [downloadId, completer.callback]);
   return completer.future;
 }

 /**
  * Resume a paused download. If the request was successful the download is in
  * progress and unpaused. Otherwise $ref:runtime.lastError contains an error
  * message. The request will fail if the download is not active.
  * [downloadId]: The id of the download to resume.
  * [callback]: Called when the resume request is completed.
  */
 Future resume(int downloadId) {
   var completer = new ChromeCompleter.noArgs();
   _downloads.callMethod('resume', [downloadId, completer.callback]);
   return completer.future;
 }

 /**
  * Cancel a download. When `callback` is run, the download is cancelled,
  * completed, interrupted or doesn't exist anymore.
  * [downloadId]: The id of the download to cancel.
  * [callback]: Called when the cancel request is completed.
  */
 Future cancel(int downloadId) {
   var completer = new ChromeCompleter.noArgs();
   _downloads.callMethod('cancel', [downloadId, completer.callback]);
   return completer.future;
 }

 /**
  * Retrieve an icon for the specified download. For new downloads, file icons
  * are available after the $ref:onCreated event has been received. The image
  * returned by this function while a download is in progress may be different
  * from the image returned after the download is complete. Icon retrieval is
  * done by querying the underlying operating system or toolkit depending on
  * the platform. The icon that is returned will therefore depend on a number
  * of factors including state of the download, platform, registered file types
  * and visual theme. If a file icon cannot be determined,
  * $ref:runtime.lastError will contain an error message.
  * [downloadId]: The identifier for the download.
  * [callback]: A URL to an image that represents the download.
  */
 Future&lt;String&gt; getFileIcon(int downloadId, [GetFileIconOptions options]) {
   var completer = new ChromeCompleter&lt;String&gt;.oneArg();
   _downloads.callMethod('getFileIcon', [downloadId, options, completer.callback]);
   return completer.future;
 }

 /**
  * Open the downloaded file now if the $ref:DownloadItem is complete;
  * otherwise returns an error through $ref:runtime.lastError. Requires the
  * `"downloads.open"` permission in addition to the `"downloads"` permission.
  * An $ref:onChanged event will fire when the item is opened for the first
  * time.
  * [downloadId]: The identifier for the downloaded file.
  */
 void open(int downloadId) {
   _downloads.callMethod('open', [downloadId]);
 }

 /**
  * Show the downloaded file in its folder in a file manager.
  * [downloadId]: The identifier for the downloaded file.
  */
 void show(int downloadId) {
   _downloads.callMethod('show', [downloadId]);
 }

 /**
  * Show the default Downloads folder in a file manager.
  */
 void showDefaultFolder() {
   _downloads.callMethod('showDefaultFolder');
 }

 /**
  * Erase matching $ref:DownloadItem from history without deleting the
  * downloaded file. An $ref:onErased event will fire for each
  * $ref:DownloadItem that matches `query`, then `callback` will be called.
  */
 Future&lt;int&gt; erase(DownloadQuery query) {
   var completer = new ChromeCompleter&lt;int&gt;.oneArg();
   _downloads.callMethod('erase', [query, completer.callback]);
   return completer.future;
 }

 /**
  * Remove the downloaded file if it exists and the $ref:DownloadItem is
  * complete; otherwise return an error through $ref:runtime.lastError.
  */
 Future removeFile(int downloadId) {
   var completer = new ChromeCompleter.noArgs();
   _downloads.callMethod('removeFile', [downloadId, completer.callback]);
   return completer.future;
 }

 /**
  * Prompt the user to accept a dangerous download. Does not automatically
  * accept dangerous downloads. If the download is accepted, then an
  * $ref:onChanged event will fire, otherwise nothing will happen.  When all
  * the data is fetched into a temporary file and either the download is not
  * dangerous or the danger has been accepted, then the temporary file is
  * renamed to the target filename, the
  * [state] changes to 'complete', and $ref:onChanged fires.
  * [downloadId]: The identifier for the $ref:DownloadItem.
  * [callback]: Called when the danger prompt dialog closes.
  */
 Future acceptDanger(int downloadId) {
   var completer = new ChromeCompleter.noArgs();
   _downloads.callMethod('acceptDanger', [downloadId, completer.callback]);
   return completer.future;
 }

 /**
  * Initiate dragging the downloaded file to another application. Call in a
  * javascript `ondragstart` handler.
  */
 void drag(int downloadId) {
   _downloads.callMethod('drag', [downloadId]);
 }

 /**
  * Enable or disable the gray shelf at the bottom of every window associated
  * with the current browser profile. The shelf will be disabled as long as at
  * least one extension has disabled it. Enabling the shelf while at least one
  * other extension has disabled it will return an error through
  * $ref:runtime.lastError. Requires the `"downloads.shelf"` permission in
  * addition to the `"downloads"` permission.
  */
 void setShelfEnabled(bool enabled) {
   _downloads.callMethod('setShelfEnabled', [enabled]);
 }

 Stream&lt;DownloadItem&gt; get onCreated =&gt; _onCreated.stream;

 final ChromeStreamController&lt;DownloadItem&gt; _onCreated =
     new ChromeStreamController&lt;DownloadItem&gt;.oneArg(_downloads['onCreated'], _createDownloadItem);

 Stream&lt;int&gt; get onErased =&gt; _onErased.stream;

 final ChromeStreamController&lt;int&gt; _onErased =
     new ChromeStreamController&lt;int&gt;.oneArg(_downloads['onErased'], selfConverter);

 Stream&lt;DownloadDelta&gt; get onChanged =&gt; _onChanged.stream;

 final ChromeStreamController&lt;DownloadDelta&gt; _onChanged =
     new ChromeStreamController&lt;DownloadDelta&gt;.oneArg(_downloads['onChanged'], _createDownloadDelta);

 Stream&lt;OnDeterminingFilenameEvent&gt; get onDeterminingFilename =&gt; _onDeterminingFilename.stream;

 final ChromeStreamController&lt;OnDeterminingFilenameEvent&gt; _onDeterminingFilename =
     new ChromeStreamController&lt;OnDeterminingFilenameEvent&gt;.twoArgs(_downloads['onDeterminingFilename'], _createOnDeterminingFilenameEvent);
}
</pre>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="onChanged">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.downloads/DownloadDelta.html">DownloadDelta</a>&gt;         <strong>onChanged</strong> <a class="anchor-link"
            href="#onChanged"
            title="Permalink to ChromeDownloads.onChanged">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;DownloadDelta&gt; get onChanged =&gt; _onChanged.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onCreated">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.downloads/DownloadItem.html">DownloadItem</a>&gt;         <strong>onCreated</strong> <a class="anchor-link"
            href="#onCreated"
            title="Permalink to ChromeDownloads.onCreated">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;DownloadItem&gt; get onCreated =&gt; _onCreated.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onDeterminingFilename">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.downloads/OnDeterminingFilenameEvent.html">OnDeterminingFilenameEvent</a>&gt;         <strong>onDeterminingFilename</strong> <a class="anchor-link"
            href="#onDeterminingFilename"
            title="Permalink to ChromeDownloads.onDeterminingFilename">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;OnDeterminingFilenameEvent&gt; get onDeterminingFilename =&gt; _onDeterminingFilename.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onErased">
<button class="show-code">Code</button>
final Stream&lt;int&gt;         <strong>onErased</strong> <a class="anchor-link"
            href="#onErased"
            title="Permalink to ChromeDownloads.onErased">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;int&gt; get onErased =&gt; _onErased.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="acceptDanger">
<button class="show-code">Code</button>
Future <strong>acceptDanger</strong>(int downloadId) <a class="anchor-link" href="#acceptDanger"
              title="Permalink to ChromeDownloads.acceptDanger">#</a></h4>
<div class="doc">
<p>Prompt the user to accept a dangerous download. Does not automatically
accept dangerous downloads. If the download is accepted, then an
$ref:onChanged event will fire, otherwise nothing will happen.  When all
the data is fetched into a temporary file and either the download is not
dangerous or the danger has been accepted, then the temporary file is
renamed to the target filename, the
<code>state</code> changes to 'complete', and $ref:onChanged fires.

<span class="param">downloadId</span>: The identifier for the $ref:DownloadItem.
<code>callback</code>: Called when the danger prompt dialog closes.</p>
<pre class="source">
Future acceptDanger(int downloadId) {
 var completer = new ChromeCompleter.noArgs();
 _downloads.callMethod('acceptDanger', [downloadId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="cancel">
<button class="show-code">Code</button>
Future <strong>cancel</strong>(int downloadId) <a class="anchor-link" href="#cancel"
              title="Permalink to ChromeDownloads.cancel">#</a></h4>
<div class="doc">
<p>Cancel a download. When <code>callback</code> is run, the download is cancelled,
completed, interrupted or doesn't exist anymore.

<span class="param">downloadId</span>: The id of the download to cancel.
<code>callback</code>: Called when the cancel request is completed.</p>
<pre class="source">
Future cancel(int downloadId) {
 var completer = new ChromeCompleter.noArgs();
 _downloads.callMethod('cancel', [downloadId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="download">
<button class="show-code">Code</button>
Future&lt;int&gt; <strong>download</strong>(<a href="../chrome.downloads/DownloadOptions.html">DownloadOptions</a> options) <a class="anchor-link" href="#download"
              title="Permalink to ChromeDownloads.download">#</a></h4>
<div class="doc">
<p>Download a URL. If the URL uses the HTTP<code>S</code> protocol, then the request will
include all cookies currently set for its hostname. If both <code>filename</code> and
<code>saveAs</code> are specified, then the Save As dialog will be displayed,
pre-populated with the specified <code>filename</code>. If the download started
successfully, <code>callback</code> will be called with the new $ref:DownloadItem's
<code>downloadId</code>. If there was an error starting the download, then <code>callback</code>
will be called with <code>downloadId=undefined</code> and $ref:runtime.lastError will
contain a descriptive string. The error strings are not guaranteed to
remain backwards compatible between releases. Extensions must not parse it.

<span class="param">options</span>: What to download and how.
<code>callback</code>: Called with the id of the new $ref:DownloadItem.</p>
<pre class="source">
Future&lt;int&gt; download(DownloadOptions options) {
 var completer = new ChromeCompleter&lt;int&gt;.oneArg();
 _downloads.callMethod('download', [options, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="drag">
<button class="show-code">Code</button>
void <strong>drag</strong>(int downloadId) <a class="anchor-link" href="#drag"
              title="Permalink to ChromeDownloads.drag">#</a></h4>
<div class="doc">
<p>Initiate dragging the downloaded file to another application. Call in a
javascript <code>ondragstart</code> handler.</p>
<pre class="source">
void drag(int downloadId) {
 _downloads.callMethod('drag', [downloadId]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="erase">
<button class="show-code">Code</button>
Future&lt;int&gt; <strong>erase</strong>(<a href="../chrome.downloads/DownloadQuery.html">DownloadQuery</a> query) <a class="anchor-link" href="#erase"
              title="Permalink to ChromeDownloads.erase">#</a></h4>
<div class="doc">
<p>Erase matching $ref:DownloadItem from history without deleting the
downloaded file. An $ref:onErased event will fire for each
$ref:DownloadItem that matches <code>query</code>, then <code>callback</code> will be called.</p>
<pre class="source">
Future&lt;int&gt; erase(DownloadQuery query) {
 var completer = new ChromeCompleter&lt;int&gt;.oneArg();
 _downloads.callMethod('erase', [query, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getFileIcon">
<button class="show-code">Code</button>
Future&lt;String&gt; <strong>getFileIcon</strong>(int downloadId, [<a href="../chrome.downloads/GetFileIconOptions.html">GetFileIconOptions</a> options]) <a class="anchor-link" href="#getFileIcon"
              title="Permalink to ChromeDownloads.getFileIcon">#</a></h4>
<div class="doc">
<p>Retrieve an icon for the specified download. For new downloads, file icons
are available after the $ref:onCreated event has been received. The image
returned by this function while a download is in progress may be different
from the image returned after the download is complete. Icon retrieval is
done by querying the underlying operating system or toolkit depending on
the platform. The icon that is returned will therefore depend on a number
of factors including state of the download, platform, registered file types
and visual theme. If a file icon cannot be determined,
$ref:runtime.lastError will contain an error message.

<span class="param">downloadId</span>: The identifier for the download.
<code>callback</code>: A URL to an image that represents the download.</p>
<pre class="source">
Future&lt;String&gt; getFileIcon(int downloadId, [GetFileIconOptions options]) {
 var completer = new ChromeCompleter&lt;String&gt;.oneArg();
 _downloads.callMethod('getFileIcon', [downloadId, options, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="open">
<button class="show-code">Code</button>
void <strong>open</strong>(int downloadId) <a class="anchor-link" href="#open"
              title="Permalink to ChromeDownloads.open">#</a></h4>
<div class="doc">
<p>Open the downloaded file now if the $ref:DownloadItem is complete;
otherwise returns an error through $ref:runtime.lastError. Requires the
<code>"downloads.open"</code> permission in addition to the <code>"downloads"</code> permission.
An $ref:onChanged event will fire when the item is opened for the first
time.

<span class="param">downloadId</span>: The identifier for the downloaded file.</p>
<pre class="source">
void open(int downloadId) {
 _downloads.callMethod('open', [downloadId]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="pause">
<button class="show-code">Code</button>
Future <strong>pause</strong>(int downloadId) <a class="anchor-link" href="#pause"
              title="Permalink to ChromeDownloads.pause">#</a></h4>
<div class="doc">
<p>Pause the download. If the request was successful the download is in a
paused state. Otherwise $ref:runtime.lastError contains an error message.
The request will fail if the download is not active.

<span class="param">downloadId</span>: The id of the download to pause.
<code>callback</code>: Called when the pause request is completed.</p>
<pre class="source">
Future pause(int downloadId) {
 var completer = new ChromeCompleter.noArgs();
 _downloads.callMethod('pause', [downloadId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="removeFile">
<button class="show-code">Code</button>
Future <strong>removeFile</strong>(int downloadId) <a class="anchor-link" href="#removeFile"
              title="Permalink to ChromeDownloads.removeFile">#</a></h4>
<div class="doc">
<p>Remove the downloaded file if it exists and the $ref:DownloadItem is
complete; otherwise return an error through $ref:runtime.lastError.</p>
<pre class="source">
Future removeFile(int downloadId) {
 var completer = new ChromeCompleter.noArgs();
 _downloads.callMethod('removeFile', [downloadId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="resume">
<button class="show-code">Code</button>
Future <strong>resume</strong>(int downloadId) <a class="anchor-link" href="#resume"
              title="Permalink to ChromeDownloads.resume">#</a></h4>
<div class="doc">
<p>Resume a paused download. If the request was successful the download is in
progress and unpaused. Otherwise $ref:runtime.lastError contains an error
message. The request will fail if the download is not active.

<span class="param">downloadId</span>: The id of the download to resume.
<code>callback</code>: Called when the resume request is completed.</p>
<pre class="source">
Future resume(int downloadId) {
 var completer = new ChromeCompleter.noArgs();
 _downloads.callMethod('resume', [downloadId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="search">
<button class="show-code">Code</button>
Future&lt;<a href="../chrome.downloads/DownloadItem.html">DownloadItem</a>&gt; <strong>search</strong>(<a href="../chrome.downloads/DownloadQuery.html">DownloadQuery</a> query) <a class="anchor-link" href="#search"
              title="Permalink to ChromeDownloads.search">#</a></h4>
<div class="doc">
<p>Find $ref:DownloadItem. Set <code>query</code> to the empty object to get all
$ref:DownloadItem. To get a specific $ref:DownloadItem, set only the <code>id</code>
field. To page through a large number of items, set <code>orderBy:
['-startTime']</code>, set <code>limit</code> to the number of items per page, and set
<code>startedAfter</code> to the <code>startTime</code> of the last item from the last page.</p>
<pre class="source">
Future&lt;DownloadItem&gt; search(DownloadQuery query) {
 var completer = new ChromeCompleter&lt;DownloadItem&gt;.oneArg(_createDownloadItem);
 _downloads.callMethod('search', [query, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setShelfEnabled">
<button class="show-code">Code</button>
void <strong>setShelfEnabled</strong>(bool enabled) <a class="anchor-link" href="#setShelfEnabled"
              title="Permalink to ChromeDownloads.setShelfEnabled">#</a></h4>
<div class="doc">
<p>Enable or disable the gray shelf at the bottom of every window associated
with the current browser profile. The shelf will be disabled as long as at
least one extension has disabled it. Enabling the shelf while at least one
other extension has disabled it will return an error through
$ref:runtime.lastError. Requires the <code>"downloads.shelf"</code> permission in
addition to the <code>"downloads"</code> permission.</p>
<pre class="source">
void setShelfEnabled(bool enabled) {
 _downloads.callMethod('setShelfEnabled', [enabled]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="show">
<button class="show-code">Code</button>
void <strong>show</strong>(int downloadId) <a class="anchor-link" href="#show"
              title="Permalink to ChromeDownloads.show">#</a></h4>
<div class="doc">
<p>Show the downloaded file in its folder in a file manager.

<span class="param">downloadId</span>: The identifier for the downloaded file.</p>
<pre class="source">
void show(int downloadId) {
 _downloads.callMethod('show', [downloadId]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="showDefaultFolder">
<button class="show-code">Code</button>
void <strong>showDefaultFolder</strong>() <a class="anchor-link" href="#showDefaultFolder"
              title="Permalink to ChromeDownloads.showDefaultFolder">#</a></h4>
<div class="doc">
<p>Show the default Downloads folder in a file manager.</p>
<pre class="source">
void showDefaultFolder() {
 _downloads.callMethod('showDefaultFolder');
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        

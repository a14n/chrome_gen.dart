        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ChromeDownloads class / chrome.downloads Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="chrome.downloads" data-type="ChromeDownloads">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../chrome.downloads.html">chrome.downloads</a> &rsaquo; <a href="../chrome.downloads/ChromeDownloads.html">ChromeDownloads</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ChromeDownloads</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class ChromeDownloads extends ChromeApi {
 static final JsObject _downloads = chrome['downloads'];

 ChromeDownloads._();

 bool get available =&gt; _downloads != null;

 /**
  * Download a URL. If the URL uses the HTTP[S] protocol, then the request will
  * include all cookies currently set for its hostname. If both `filename` and
  * `saveAs` are specified, then the Save As dialog will be displayed,
  * pre-populated with the specified `filename`. If the download started
  * successfully, `callback` will be called with the new [DownloadItem]'s
  * `downloadId`. If there was an error starting the download, then `callback`
  * will be called with `downloadId=undefined` and [runtime.lastError] will
  * contain a descriptive string. The error strings are not guaranteed to
  * remain backwards compatible between releases. Extensions must not parse it.
  * [options]: What to download and how.
  * [callback]: Called with the id of the new [DownloadItem].
  */
 Future&lt;int&gt; download(DownloadOptions options) {
   if (_downloads == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;int&gt;.oneArg();
   _downloads.callMethod('download', [jsify(options), completer.callback]);
   return completer.future;
 }

 /**
  * Find [DownloadItem]. Set `query` to the empty object to get all
  * [DownloadItem]. To get a specific [DownloadItem], set only the `id` field.
  * To page through a large number of items, set `orderBy: ['-startTime']`, set
  * `limit` to the number of items per page, and set `startedAfter` to the
  * `startTime` of the last item from the last page.
  */
 Future&lt;List&lt;DownloadItem&gt;&gt; search(DownloadQuery query) {
   if (_downloads == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;List&lt;DownloadItem&gt;&gt;.oneArg((e) =&gt; listify(e, _createDownloadItem));
   _downloads.callMethod('search', [jsify(query), completer.callback]);
   return completer.future;
 }

 /**
  * Pause the download. If the request was successful the download is in a
  * paused state. Otherwise [runtime.lastError] contains an error message. The
  * request will fail if the download is not active.
  * [downloadId]: The id of the download to pause.
  * [callback]: Called when the pause request is completed.
  */
 Future pause(int downloadId) {
   if (_downloads == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _downloads.callMethod('pause', [downloadId, completer.callback]);
   return completer.future;
 }

 /**
  * Resume a paused download. If the request was successful the download is in
  * progress and unpaused. Otherwise [runtime.lastError] contains an error
  * message. The request will fail if the download is not active.
  * [downloadId]: The id of the download to resume.
  * [callback]: Called when the resume request is completed.
  */
 Future resume(int downloadId) {
   if (_downloads == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _downloads.callMethod('resume', [downloadId, completer.callback]);
   return completer.future;
 }

 /**
  * Cancel a download. When `callback` is run, the download is cancelled,
  * completed, interrupted or doesn't exist anymore.
  * [downloadId]: The id of the download to cancel.
  * [callback]: Called when the cancel request is completed.
  */
 Future cancel(int downloadId) {
   if (_downloads == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _downloads.callMethod('cancel', [downloadId, completer.callback]);
   return completer.future;
 }

 /**
  * Retrieve an icon for the specified download. For new downloads, file icons
  * are available after the [onCreated] event has been received. The image
  * returned by this function while a download is in progress may be different
  * from the image returned after the download is complete. Icon retrieval is
  * done by querying the underlying operating system or toolkit depending on
  * the platform. The icon that is returned will therefore depend on a number
  * of factors including state of the download, platform, registered file types
  * and visual theme. If a file icon cannot be determined, [runtime.lastError]
  * will contain an error message.
  * [downloadId]: The identifier for the download.
  * [callback]: A URL to an image that represents the download.
  */
 Future&lt;String&gt; getFileIcon(int downloadId, [GetFileIconOptions options]) {
   if (_downloads == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;String&gt;.oneArg();
   _downloads.callMethod('getFileIcon', [downloadId, jsify(options), completer.callback]);
   return completer.future;
 }

 /**
  * Open the downloaded file now if the [DownloadItem] is complete; otherwise
  * returns an error through [runtime.lastError]. Requires the
  * `"downloads.open"` permission in addition to the `"downloads"` permission.
  * An [onChanged] event will fire when the item is opened for the first time.
  * [downloadId]: The identifier for the downloaded file.
  */
 void open(int downloadId) {
   if (_downloads == null) _throwNotAvailable();

   _downloads.callMethod('open', [downloadId]);
 }

 /**
  * Show the downloaded file in its folder in a file manager.
  * [downloadId]: The identifier for the downloaded file.
  */
 void show(int downloadId) {
   if (_downloads == null) _throwNotAvailable();

   _downloads.callMethod('show', [downloadId]);
 }

 /**
  * Show the default Downloads folder in a file manager.
  */
 void showDefaultFolder() {
   if (_downloads == null) _throwNotAvailable();

   _downloads.callMethod('showDefaultFolder');
 }

 /**
  * Erase matching [DownloadItem] from history without deleting the downloaded
  * file. An [onErased] event will fire for each [DownloadItem] that matches
  * `query`, then `callback` will be called.
  */
 Future&lt;List&lt;int&gt;&gt; erase(DownloadQuery query) {
   if (_downloads == null) _throwNotAvailable();

   var completer = new ChromeCompleter&lt;List&lt;int&gt;&gt;.oneArg(listify);
   _downloads.callMethod('erase', [jsify(query), completer.callback]);
   return completer.future;
 }

 /**
  * Remove the downloaded file if it exists and the [DownloadItem] is complete;
  * otherwise return an error through [runtime.lastError].
  */
 Future removeFile(int downloadId) {
   if (_downloads == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _downloads.callMethod('removeFile', [downloadId, completer.callback]);
   return completer.future;
 }

 /**
  * Prompt the user to accept a dangerous download. Does not automatically
  * accept dangerous downloads. If the download is accepted, then an
  * [onChanged] event will fire, otherwise nothing will happen. When all the
  * data is fetched into a temporary file and either the download is not
  * dangerous or the danger has been accepted, then the temporary file is
  * renamed to the target filename, the [state] changes to 'complete', and
  * [onChanged] fires.
  * [downloadId]: The identifier for the [DownloadItem].
  * [callback]: Called when the danger prompt dialog closes.
  */
 Future acceptDanger(int downloadId) {
   if (_downloads == null) _throwNotAvailable();

   var completer = new ChromeCompleter.noArgs();
   _downloads.callMethod('acceptDanger', [downloadId, completer.callback]);
   return completer.future;
 }

 /**
  * Initiate dragging the downloaded file to another application. Call in a
  * javascript `ondragstart` handler.
  */
 void drag(int downloadId) {
   if (_downloads == null) _throwNotAvailable();

   _downloads.callMethod('drag', [downloadId]);
 }

 /**
  * Enable or disable the gray shelf at the bottom of every window associated
  * with the current browser profile. The shelf will be disabled as long as at
  * least one extension has disabled it. Enabling the shelf while at least one
  * other extension has disabled it will return an error through
  * [runtime.lastError]. Requires the `"downloads.shelf"` permission in
  * addition to the `"downloads"` permission.
  */
 void setShelfEnabled(bool enabled) {
   if (_downloads == null) _throwNotAvailable();

   _downloads.callMethod('setShelfEnabled', [enabled]);
 }

 Stream&lt;DownloadItem&gt; get onCreated =&gt; _onCreated.stream;

 final ChromeStreamController&lt;DownloadItem&gt; _onCreated =
     new ChromeStreamController&lt;DownloadItem&gt;.oneArg(_downloads, 'onCreated', _createDownloadItem);

 Stream&lt;int&gt; get onErased =&gt; _onErased.stream;

 final ChromeStreamController&lt;int&gt; _onErased =
     new ChromeStreamController&lt;int&gt;.oneArg(_downloads, 'onErased', selfConverter);

 Stream&lt;DownloadDelta&gt; get onChanged =&gt; _onChanged.stream;

 final ChromeStreamController&lt;DownloadDelta&gt; _onChanged =
     new ChromeStreamController&lt;DownloadDelta&gt;.oneArg(_downloads, 'onChanged', _createDownloadDelta);

 Stream&lt;OnDeterminingFilenameEvent&gt; get onDeterminingFilename =&gt; _onDeterminingFilename.stream;

 final ChromeStreamController&lt;OnDeterminingFilenameEvent&gt; _onDeterminingFilename =
     new ChromeStreamController&lt;OnDeterminingFilenameEvent&gt;.twoArgs(_downloads, 'onDeterminingFilename', _createOnDeterminingFilenameEvent);

 void _throwNotAvailable() {
   throw new UnsupportedError("'chrome.downloads' is not available");
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>ChromeDownloads</strong></span></p>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="available">
<button class="show-code">Code</button>
final bool         <strong>available</strong> <a class="anchor-link"
            href="#available"
            title="Permalink to ChromeDownloads.available">#</a>
        </h4>
        <div class="doc">
<div class="inherited">
<p>Returns true if the API is available. The common causes of an API not being
avilable are:</p><ul><li>a permission is missing in the application's manifest.json file</li><li>the API is defined on a newer version of Chrome then the current runtime</li></ul>
<div class="docs-inherited-from">docs inherited from <a href="../chrome.src.common_exp/ChromeApi.html">ChromeApi</a> </div></div>
<pre class="source">
bool get available =&gt; _downloads != null;
</pre>
</div>
</div>
<div class="field"><h4 id="onChanged">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.downloads/DownloadDelta.html">DownloadDelta</a>&gt;         <strong>onChanged</strong> <a class="anchor-link"
            href="#onChanged"
            title="Permalink to ChromeDownloads.onChanged">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;DownloadDelta&gt; get onChanged =&gt; _onChanged.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onCreated">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.downloads/DownloadItem.html">DownloadItem</a>&gt;         <strong>onCreated</strong> <a class="anchor-link"
            href="#onCreated"
            title="Permalink to ChromeDownloads.onCreated">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;DownloadItem&gt; get onCreated =&gt; _onCreated.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onDeterminingFilename">
<button class="show-code">Code</button>
final Stream&lt;<a href="../chrome.downloads/OnDeterminingFilenameEvent.html">OnDeterminingFilenameEvent</a>&gt;         <strong>onDeterminingFilename</strong> <a class="anchor-link"
            href="#onDeterminingFilename"
            title="Permalink to ChromeDownloads.onDeterminingFilename">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;OnDeterminingFilenameEvent&gt; get onDeterminingFilename =&gt; _onDeterminingFilename.stream;
</pre>
</div>
</div>
<div class="field"><h4 id="onErased">
<button class="show-code">Code</button>
final Stream&lt;int&gt;         <strong>onErased</strong> <a class="anchor-link"
            href="#onErased"
            title="Permalink to ChromeDownloads.onErased">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;int&gt; get onErased =&gt; _onErased.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="acceptDanger">
<button class="show-code">Code</button>
Future <strong>acceptDanger</strong>(int downloadId) <a class="anchor-link" href="#acceptDanger"
              title="Permalink to ChromeDownloads.acceptDanger">#</a></h4>
<div class="doc">
<p>Prompt the user to accept a dangerous download. Does not automatically
accept dangerous downloads. If the download is accepted, then an
<a class="crossref" href="../chrome.downloads/ChromeDownloads.html#onChanged">onChanged</a> event will fire, otherwise nothing will happen. When all the
data is fetched into a temporary file and either the download is not
dangerous or the danger has been accepted, then the temporary file is
renamed to the target filename, the <code>state</code> changes to 'complete', and
<a class="crossref" href="../chrome.downloads/ChromeDownloads.html#onChanged">onChanged</a> fires.

<span class="param">downloadId</span>: The identifier for the <a class="crossref" href="../chrome.downloads/DownloadItem.html">DownloadItem</a>.
<code>callback</code>: Called when the danger prompt dialog closes.</p>
<pre class="source">
Future acceptDanger(int downloadId) {
 if (_downloads == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _downloads.callMethod('acceptDanger', [downloadId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="cancel">
<button class="show-code">Code</button>
Future <strong>cancel</strong>(int downloadId) <a class="anchor-link" href="#cancel"
              title="Permalink to ChromeDownloads.cancel">#</a></h4>
<div class="doc">
<p>Cancel a download. When <code>callback</code> is run, the download is cancelled,
completed, interrupted or doesn't exist anymore.

<span class="param">downloadId</span>: The id of the download to cancel.
<code>callback</code>: Called when the cancel request is completed.</p>
<pre class="source">
Future cancel(int downloadId) {
 if (_downloads == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _downloads.callMethod('cancel', [downloadId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="download">
<button class="show-code">Code</button>
Future&lt;int&gt; <strong>download</strong>(<a href="../chrome.downloads/DownloadOptions.html">DownloadOptions</a> options) <a class="anchor-link" href="#download"
              title="Permalink to ChromeDownloads.download">#</a></h4>
<div class="doc">
<p>Download a URL. If the URL uses the HTTP<code>S</code> protocol, then the request will
include all cookies currently set for its hostname. If both <code>filename</code> and
<code>saveAs</code> are specified, then the Save As dialog will be displayed,
pre-populated with the specified <code>filename</code>. If the download started
successfully, <code>callback</code> will be called with the new <a class="crossref" href="../chrome.downloads/DownloadItem.html">DownloadItem</a>'s
<code>downloadId</code>. If there was an error starting the download, then <code>callback</code>
will be called with <code>downloadId=undefined</code> and <code>runtime.lastError</code> will
contain a descriptive string. The error strings are not guaranteed to
remain backwards compatible between releases. Extensions must not parse it.

<span class="param">options</span>: What to download and how.
<code>callback</code>: Called with the id of the new <a class="crossref" href="../chrome.downloads/DownloadItem.html">DownloadItem</a>.</p>
<pre class="source">
Future&lt;int&gt; download(DownloadOptions options) {
 if (_downloads == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;int&gt;.oneArg();
 _downloads.callMethod('download', [jsify(options), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="drag">
<button class="show-code">Code</button>
void <strong>drag</strong>(int downloadId) <a class="anchor-link" href="#drag"
              title="Permalink to ChromeDownloads.drag">#</a></h4>
<div class="doc">
<p>Initiate dragging the downloaded file to another application. Call in a
javascript <code>ondragstart</code> handler.</p>
<pre class="source">
void drag(int downloadId) {
 if (_downloads == null) _throwNotAvailable();

 _downloads.callMethod('drag', [downloadId]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="erase">
<button class="show-code">Code</button>
Future&lt;List&lt;int&gt;&gt; <strong>erase</strong>(<a href="../chrome.downloads/DownloadQuery.html">DownloadQuery</a> query) <a class="anchor-link" href="#erase"
              title="Permalink to ChromeDownloads.erase">#</a></h4>
<div class="doc">
<p>Erase matching <a class="crossref" href="../chrome.downloads/DownloadItem.html">DownloadItem</a> from history without deleting the downloaded
file. An <a class="crossref" href="../chrome.downloads/ChromeDownloads.html#onErased">onErased</a> event will fire for each <a class="crossref" href="../chrome.downloads/DownloadItem.html">DownloadItem</a> that matches
<code>query</code>, then <code>callback</code> will be called.</p>
<pre class="source">
Future&lt;List&lt;int&gt;&gt; erase(DownloadQuery query) {
 if (_downloads == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;List&lt;int&gt;&gt;.oneArg(listify);
 _downloads.callMethod('erase', [jsify(query), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getFileIcon">
<button class="show-code">Code</button>
Future&lt;String&gt; <strong>getFileIcon</strong>(int downloadId, [<a href="../chrome.downloads/GetFileIconOptions.html">GetFileIconOptions</a> options]) <a class="anchor-link" href="#getFileIcon"
              title="Permalink to ChromeDownloads.getFileIcon">#</a></h4>
<div class="doc">
<p>Retrieve an icon for the specified download. For new downloads, file icons
are available after the <a class="crossref" href="../chrome.downloads/ChromeDownloads.html#onCreated">onCreated</a> event has been received. The image
returned by this function while a download is in progress may be different
from the image returned after the download is complete. Icon retrieval is
done by querying the underlying operating system or toolkit depending on
the platform. The icon that is returned will therefore depend on a number
of factors including state of the download, platform, registered file types
and visual theme. If a file icon cannot be determined, <code>runtime.lastError</code>
will contain an error message.

<span class="param">downloadId</span>: The identifier for the download.
<code>callback</code>: A URL to an image that represents the download.</p>
<pre class="source">
Future&lt;String&gt; getFileIcon(int downloadId, [GetFileIconOptions options]) {
 if (_downloads == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;String&gt;.oneArg();
 _downloads.callMethod('getFileIcon', [downloadId, jsify(options), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="open">
<button class="show-code">Code</button>
void <strong>open</strong>(int downloadId) <a class="anchor-link" href="#open"
              title="Permalink to ChromeDownloads.open">#</a></h4>
<div class="doc">
<p>Open the downloaded file now if the <a class="crossref" href="../chrome.downloads/DownloadItem.html">DownloadItem</a> is complete; otherwise
returns an error through <code>runtime.lastError</code>. Requires the
<code>"downloads.open"</code> permission in addition to the <code>"downloads"</code> permission.
An <a class="crossref" href="../chrome.downloads/ChromeDownloads.html#onChanged">onChanged</a> event will fire when the item is opened for the first time.

<span class="param">downloadId</span>: The identifier for the downloaded file.</p>
<pre class="source">
void open(int downloadId) {
 if (_downloads == null) _throwNotAvailable();

 _downloads.callMethod('open', [downloadId]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="pause">
<button class="show-code">Code</button>
Future <strong>pause</strong>(int downloadId) <a class="anchor-link" href="#pause"
              title="Permalink to ChromeDownloads.pause">#</a></h4>
<div class="doc">
<p>Pause the download. If the request was successful the download is in a
paused state. Otherwise <code>runtime.lastError</code> contains an error message. The
request will fail if the download is not active.

<span class="param">downloadId</span>: The id of the download to pause.
<code>callback</code>: Called when the pause request is completed.</p>
<pre class="source">
Future pause(int downloadId) {
 if (_downloads == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _downloads.callMethod('pause', [downloadId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="removeFile">
<button class="show-code">Code</button>
Future <strong>removeFile</strong>(int downloadId) <a class="anchor-link" href="#removeFile"
              title="Permalink to ChromeDownloads.removeFile">#</a></h4>
<div class="doc">
<p>Remove the downloaded file if it exists and the <a class="crossref" href="../chrome.downloads/DownloadItem.html">DownloadItem</a> is complete;
otherwise return an error through <code>runtime.lastError</code>.</p>
<pre class="source">
Future removeFile(int downloadId) {
 if (_downloads == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _downloads.callMethod('removeFile', [downloadId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="resume">
<button class="show-code">Code</button>
Future <strong>resume</strong>(int downloadId) <a class="anchor-link" href="#resume"
              title="Permalink to ChromeDownloads.resume">#</a></h4>
<div class="doc">
<p>Resume a paused download. If the request was successful the download is in
progress and unpaused. Otherwise <code>runtime.lastError</code> contains an error
message. The request will fail if the download is not active.

<span class="param">downloadId</span>: The id of the download to resume.
<code>callback</code>: Called when the resume request is completed.</p>
<pre class="source">
Future resume(int downloadId) {
 if (_downloads == null) _throwNotAvailable();

 var completer = new ChromeCompleter.noArgs();
 _downloads.callMethod('resume', [downloadId, completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="search">
<button class="show-code">Code</button>
Future&lt;List&lt;<a href="../chrome.downloads/DownloadItem.html">DownloadItem</a>&gt;&gt; <strong>search</strong>(<a href="../chrome.downloads/DownloadQuery.html">DownloadQuery</a> query) <a class="anchor-link" href="#search"
              title="Permalink to ChromeDownloads.search">#</a></h4>
<div class="doc">
<p>Find <a class="crossref" href="../chrome.downloads/DownloadItem.html">DownloadItem</a>. Set <code>query</code> to the empty object to get all
<a class="crossref" href="../chrome.downloads/DownloadItem.html">DownloadItem</a>. To get a specific <a class="crossref" href="../chrome.downloads/DownloadItem.html">DownloadItem</a>, set only the <code>id</code> field.
To page through a large number of items, set <code>orderBy: ['-startTime']</code>, set
<code>limit</code> to the number of items per page, and set <code>startedAfter</code> to the
<code>startTime</code> of the last item from the last page.</p>
<pre class="source">
Future&lt;List&lt;DownloadItem&gt;&gt; search(DownloadQuery query) {
 if (_downloads == null) _throwNotAvailable();

 var completer = new ChromeCompleter&lt;List&lt;DownloadItem&gt;&gt;.oneArg((e) =&gt; listify(e, _createDownloadItem));
 _downloads.callMethod('search', [jsify(query), completer.callback]);
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setShelfEnabled">
<button class="show-code">Code</button>
void <strong>setShelfEnabled</strong>(bool enabled) <a class="anchor-link" href="#setShelfEnabled"
              title="Permalink to ChromeDownloads.setShelfEnabled">#</a></h4>
<div class="doc">
<p>Enable or disable the gray shelf at the bottom of every window associated
with the current browser profile. The shelf will be disabled as long as at
least one extension has disabled it. Enabling the shelf while at least one
other extension has disabled it will return an error through
<code>runtime.lastError</code>. Requires the <code>"downloads.shelf"</code> permission in
addition to the <code>"downloads"</code> permission.</p>
<pre class="source">
void setShelfEnabled(bool enabled) {
 if (_downloads == null) _throwNotAvailable();

 _downloads.callMethod('setShelfEnabled', [enabled]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="show">
<button class="show-code">Code</button>
void <strong>show</strong>(int downloadId) <a class="anchor-link" href="#show"
              title="Permalink to ChromeDownloads.show">#</a></h4>
<div class="doc">
<p>Show the downloaded file in its folder in a file manager.

<span class="param">downloadId</span>: The identifier for the downloaded file.</p>
<pre class="source">
void show(int downloadId) {
 if (_downloads == null) _throwNotAvailable();

 _downloads.callMethod('show', [downloadId]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="showDefaultFolder">
<button class="show-code">Code</button>
void <strong>showDefaultFolder</strong>() <a class="anchor-link" href="#showDefaultFolder"
              title="Permalink to ChromeDownloads.showDefaultFolder">#</a></h4>
<div class="doc">
<p>Show the default Downloads folder in a file manager.</p>
<pre class="source">
void showDefaultFolder() {
 if (_downloads == null) _throwNotAvailable();

 _downloads.callMethod('showDefaultFolder');
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
